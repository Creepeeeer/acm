### **分治法能解决的问题一般有如下特征：**

- 该问题的规模缩小到一定的程度就可以容易地解决。
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。



## 找到平面内两点间欧几里得距离最小值

[P7883 平面最近点对（加强加强版） - 洛谷](https://www.luogu.com.cn/problem/P7883)

```c++
#include<bits/stdc++.h>
#define pa pair<ll,ll>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf =0x3f3f3f3f;
const int N=4e5;
ll an=2e18;
int n;
pa a[N+1];
bool cmp1(pa a,pa b){return a.first<b.first;}
bool cmp2(pa a,pa b){return a.second<b.second;}
ll dis(pa a,pa b){
	return 1ll*(a.first-b.first)*(a.first-b.first)+1ll*(a.second-b.second)*(a.second-b.second);
}
void merge(int l,int r){
	if(l==r)return;
	if(r==l+1){an=min(an,dis(a[l],a[r]));return;}
	int m=(l+r)>>1;
	merge(l,m);
	merge(m+1,r);
	vector<pa>te;
	int sign=m;
	while(sign<=r&&powl(a[sign].first-a[m].first,2)<=an){
		te.push_back(a[sign]);
		sign++;
	}
	sign=m-1;
	while(sign>=l&&powl(a[m].first-a[sign].first,2)<=an){
		te.push_back(a[sign]);
		sign--;
	}
	sort(te.begin(),te.end(),cmp2);
	for(int i=0;i<(int)te.size()-1;i++){
		int sign=i+1;
		while(sign<te.size()&&powl(te[sign].second-te[i].second,2)<=an){
			an=min(an,dis(te[i],te[sign]));
			sign++;
		}
	}
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i].first>>a[i].second;
    sort(a+1,a+n+1,cmp1);
	merge(1,n);
	cout<<an<<endl;
    return 0;
}
```

