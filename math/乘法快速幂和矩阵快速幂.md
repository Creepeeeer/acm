## 乘法快速幂

```c++
int ksm(int a,int b){
ll re=1;
while(b){
if(b&1){
re=re*a%mod;
}
b>>=1;
a=1ll*a*a%mod;
}
return re;
}
```



## 矩阵快速幂

**给定一个 k * k 的矩阵乘n次  时间复杂度是O(logn * k^3)**

```c++
vector<vector<int>> multiply(vector<vector<int>>&a,vector<vector<int>>&b){
    int n=a.size(),m=b[0].size(),p=b.size();
    vector<vector<int>>an(n,vector<int>(m));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            for(int k=0;k<p;k++){
                an[i][j]+=a[i][k]*b[k][j];
            }
        }
    }
    return an;
}
vector<vector<int>> ksm(vector<vector<int>>&a,int b){
    int n=a.size();
    vector<vector<int>>re(n,vector<int>(n,0));
    for(int i=0;i<n;i++)re[i][i]=1;
    while(b){
        if(b&1)re=multiply(re,a);
        b>>=1;
        a=multiply(a,a);
    }
    return re;
}
```

**ps ：矩阵快速幂只能计算正方形矩阵**



### 1.固定关系的1维k阶递推表达式

即dp表只有一维参数，dp<sub>i</sub>=x<sub>1</sub>*dp<sub>i-1</sub>+.......x<sub>k</sub>*dp<sub>i-k</sub>

其中x<sub>i</sub>可以为任何数包括0

**方法：**

首先给出一个1行k列的矩阵表示初始值{dp<sub>k</sub>,.......dp<sub>1</sub>},然后乘以一个k*k的矩阵n-k次，得到矩阵{dp<sub>n</sub>......dp<sub>n-k+1</sub>}

k*k矩阵的第一列为{x<sub>1</sub>....x<sub>k</sub>}

剩下的系数通过带入前几项得到

e.g.斐波那契数 f<sub>0</sub>=0,f<sub>1</sub>=1

初始矩阵{1，0}，关系矩阵{{1，1}，{x,y}}

待定系数求出x=1，y=0

然后求n-1次关系矩阵然后初始矩阵再乘以关系矩阵

```c++
if(n==0)return 0;
        vector<vector<int>>re;
        vector<int>te={1,0};
        re.push_back(te);
        vector<vector<int>>b={{1,1},{1,0}};
        b=ksm(b,n-1);
        re=multiply(re,b);
        return re[0][0];
```





### 2.固定关系的k维1阶递推表达式

其中dp表有两维参数,dp<sub>i,j</sub>=x1dp<sub>i-1,0</sub>+......xkdp<sub>i-1,k-1</sub>（j>=0&&j<k)

**方法**：

和上几乎一样

k维则取一个k*k矩阵，然后第p行q列系数则为dp<sub>i,q-1</sub>表达式中xp来决定

此时整个矩阵可以直接得到不需要待定系数了

