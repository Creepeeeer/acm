## **一、中位数问题**

### **1. 问题模型**

数轴x上有n个点，现在给出这n个点的坐标a[i](i∈[1,n])，让你选择一个点k(k∈[1,n])，使得每个点到点k的距离之和最小。

### **2. 结论**

点k为序列的中位数时最优：
若n为奇数，点k位于a[(n+1)/2]处最优；若n为偶数，点k位于a[n/2]或a[n/2+1]均为

### **3. 推导**

![图片28.png](https://i.loli.net/2019/11/09/8exvKDS4aFcOtg1.png)
首先将a[1]~a[n]排序，假设点p选在坐标q处，点p左侧有l个点，点p右侧有r个点，此时分为两种情况：
l<r，若点p向右移动单位距离，则距离之和减小(r−l)。
r<l，若点p向左移动单位距离，则距离之和减小(l−r)。

因此保证点p的左侧节点和右侧节点数量尽量相等时（即l=r），距离之和最优。

该结论同样适用于求出最优点k，当点k的左右两侧节点数相等时为最优解，此时k就是序列的中位数。此时无论左移或右移点k都会使结果更差。



## **二、带权中位数问题**

### **1. 问题模型**

数轴x上有n个点，现在给出这n个点的坐标a[i](i∈[1,n])以及这n个点的点权num[i]，让你选择一个点k(k∈[1,n])，使得每个点到点k的距离与点权的乘积之和最小。

### **2. 结论**

满足∑ki=1num[i]≥tot/2时(tot为所有点权之和)的最小点k为最优点。

### **3. 推导**

可以把每个节点i由原来只有一个节点看做有num[i]个点同时位于坐标i上，此时我们知道当点k位于tot/2的坐标上最优。







## **二分中位数**

[Problem - E1 - Codeforces](https://codeforces.com/contest/2128/problem/E1)

去二分中位数，每次维护一个pre数组

```c++
    for(int i=1;i<=n;i++)pre[i]=pre[i-1]+(a[i]>=m?1:-1);
```

那么只需要找到一个区间至少长度至少为k的pre[r]-pre[l-1]>=0

```c++
    for(int i=1;i<=n-1;i++){
        if(pre[i]<mi[i-1]){
            mi[i]=pre[i];
            sign[i]=i;
        }
        else{
            mi[i]=mi[i-1];
            sign[i]=sign[i-1];
        }
    }
    for(int i=k,j=0;i<=n;i++,j++){
        if(pre[i]>=mi[j]){
            x=m,y=sign[j]+1,z=i;
            return true;
        }
    }
    return false;
```

