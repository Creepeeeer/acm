**基环树定义：**n个顶点里有n条边的连通图，有且仅有一个环

**基环树森林**：n个顶点里有n条边，图不一定联通所以有多个环，**等效定义**：如果一个有向图每个点的出度为1，那么这个图变成无向图也是一个基环树森林

**如何找到每个基环树里的环**：

使用并查集每次给的一条边如果$find(u)!=find(v)$，就并起来，否则这两个点就是环上的两个点，可以从u dfs到v即可得到整个环

**做题的两个方法：**

1.把环抽出来，这样整个图就变成一个环上面挂了几个子树的样子了，然后对子树进行操作，将信息合并到环上的节点，最后就能把一个图上的问题降到环上处理

<img src="https://cdn.luogu.com.cn/upload/image_hosting/o1zb18wy.png" alt="img" style="zoom: 50%;" />

2.先忽略掉导致整棵树出现环的一条边，然后对剩下的树进行操作

<img src="https://cdn.luogu.com.cn/upload/image_hosting/flti3dxz.png" alt="img" style="zoom:50%;" />

**基环树的最长链**

链的可能性为不含环上的边或者含环上的边

先找出环然后以环上点为根的子树树形dp找出该子树的含根最长链和子树直径，含环上的边的答案就是选环上的两个点计算他们之间的距离加上他们的含根最长链

暴力是$O(n^2)$的考虑优化我们先把环拆开然后倍增为2倍，每个点维护它之前边权的前缀和，那么

$sum=dp[u]+pre[u]+dp[v]-pre[v]$,使用单调队列维护$dp[v]-pre[v]$的最大值就可以

```c++
int n;
struct edge {
    int u, v, w;
};
vector<edge>e;
vector<edge>g[N + 1];
vector<int>scc[N + 1];
bool cir[N + 1], ciredge[N + 1];
int fa[N + 1];
unordered_map<int, edge>ump;
vector<pll>circle;
ll dp[N + 1];
int find(int x) {
    if (x != fa[x])fa[x] = find(fa[x]);
    return fa[x];
}
void un(int x, int y) {
    x = find(x), y = find(y);
    if (x > y)swap(x, y);
    fa[y] = x;
    if (cir[y]) {
        ump[x] = ump[y];
    }
    cir[x] = cir[x] || cir[y];
}
ll dfs1(int u, int f) {
    ll an = 0, ma = 0, sema = 0;
    for (auto& [v, w, i] : g[u]) {
        if (v == f || ciredge[i])continue;
        an = max(an, dfs1(v, u));
        if (dp[v] + w > ma) {
            sema = ma;
            ma = dp[v] + w;
        }
        else if (dp[v] + w > sema)sema = dp[v] + w;
    }
    dp[u] = ma;
    return max(an, ma + sema);
}
bool dfs2(int u, int f, int goal) {
    if (u == goal)return true;
    for (auto& [v, w, i] : g[u]) {
        if (v == f || ciredge[i])continue;
        if (dfs2(v, u, goal)) {
            circle.push_back({ u, w });
            ciredge[i] = true;
            return true;
        }
    }
    return false;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n;
    e.resize(n + 1);
    fill(ciredge, ciredge + n + 1, false);
    fill(cir, cir + n + 1, false);
    iota(fa, fa + n + 1, 0);
    for (int i = 1; i <= n; i++) {
        int v, w;
        cin >> v >> w;
        if (find(i) != find(v)) {
            un(i, v);
        }
        else {
            ciredge[i] = true;
            cir[find(i)] = true;
            ump[find(i)] = { i, v, w };
        }
        e[i] = { i, v, w };
        g[i].push_back({ v, w, i });
        g[v].push_back({ i, w, i });
    }
    vector<int>nums;
    for (int i = 1; i <= n; i++) {
        scc[find(i)].push_back(i);
        nums.push_back(find(i));
    }
    sort(all(nums));
    nums.erase(unique(all(nums)), nums.end());
    ll an = 0;
    for (auto& x : nums) {
        if (cir[x]) {
            ll te1 = 0, te2 = 0;
            auto& [p, q, w] = ump[x];
            circle.clear();
            dfs2(p, 0, q);
            reverse(all(circle));
            circle.push_back({ q, w });
            for (auto& [p, v] : circle) {
                te1 = max(te1, dfs1(p, 0));
            }
            int m = circle.size();
            for (int i = 0; i < m; i++) {
                circle.push_back(circle[i]);
            }
            vector<ll>pre(2 * m+1);
            pre[0] = 0;
            for (int i = 1; i <= 2 * m; i++)pre[i] = pre[i - 1] + circle[i-1].second;
            deque<pii>de;
            for (int r = 0; r < 2 * m;r++) {
                int val = circle[r].first;
                while (de.front().second <=r-m )de.pop_front();
                if(!de.empty())
                te2 = max(te2, dp[val] + pre[r] + dp[de.front().first] - pre[de.front().second]);
                while (!de.empty() && dp[de.back().first] - pre[de.back().second] < dp[val] - pre[r]) {
                    de.pop_back();
                }
                de.push_back({ val, r });
            }
            an += max(te1, te2);
        }
        else {
            an += dfs1(x, 0);
        }
    }
    cout << an;
```

