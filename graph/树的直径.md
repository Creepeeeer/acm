## 定义：树上距离最远的两个点，形成的路径叫做树的直径

**此时的距离可以带权**

### 树的直径的两种求法

#### 1.两次dfs(适用于边权非负的树)

从树的根节点走到离根节点最远的点x，再从x走到离x最远的点y，那么x->y就是一条直径

```c++
int n;
int fa[N+1],dis[N+1];//fa数组用来记录路径
void dfs(int u,int f,int len){
	fa[u]=f;
	dis[u]=dis[f]+len;
	for(auto[v,w]:g[u]){
		if(v!=f)dfs(v,u,w);
	}
}

//main
  }
    dfs(1,0,0);
    int c=1,maxlen=0;
    for(int i=1;i<=n;i++){
    	if(dis[i]>maxlen){
    		maxlen=dis[i];
    		c=i;
    	}
    }
    dfs(c,0,0);
    int an=0;
    for(int i=1;i<=n;i++)an=max(an,dis[i]);
    cout<<an<<endl;
```



#### 2.树形dp

```c++
int dis[N+1],down[N+1];//dis[u]表示必须经过u节点的最大路径 down[u]表示从u向下的最大路径
void dfs(int u,int f){
	for(auto&[v,w]:g[u]){
		if(v!=f){
			dfs(v,u);
			dis[u]=max(dis[u],down[u]+down[v]+w);
			down[u]=max(down[u],w+down[v]);
		}
	}
}
//main
dfs(1,0);
    int an=0;
    for(int i=1;i<=n;i++)an=max(an,dis[i]);
    cout<<an<<endl;
```



#### 比较

两次dfs可以得到路径但是处理不了负权图，树形dp可以处理负权图但是不能得到路径



#### 一些如果边权都为为正的结论

**如果有多条直径，那么这些直径一定有共同的中间部分，可能是一个公共点或一段公共路径**

**树上任意一点，相隔最远的点的集合，直径的两个端点至少有一个在这个集合里面**



[P2195 HXY造公园 - 洛谷](https://www.luogu.com.cn/problem/P2195)

两棵树自由连接后最小直径为max(disx,disy,(disx+1)/2+(disy+1)/2+1)

