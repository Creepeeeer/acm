# 重链剖分（根据儿子的子树大小来决定重儿子划分）

#### 初始化，需要维护的信息：

**fa,dep,siz,son（重儿子，子树大小最大的儿子，如果有多个任选其一）,top（所在重链的头结点）,dfn,seg（seg[i]表示dfn序为i的节点，即seg[dfn[i]]=i)**

通过两次dfs维护：

第一次维护fa，dep，siz，son

第二次维护 top,dfn,seg,先遍历重儿子再依次遍历轻儿子

父节点与重儿子属于同一条重链拥有同样的top,轻儿子自己作为一条新重链的top

**任何节点到达树的头结点时间复杂度O(logn)**

```c++
int siz[N+1],dfn[N+1],fa[N+1],son[N+1],dep[N+1],seg[N+1],top[N+1];
int cnt=0;
void dfs1(int u, int f) {
	fa[u] = f;
	dep[u] = dep[f] + 1;
    siz[u]=1;
	for (auto v : g[u]) {
		if (v == f)continue;
		dfs1(v, u);
		siz[u] += siz[v];
		if (siz[son[u]] < siz[v]) {
			son[u] = v;
		}
	}
}
void dfs2(int u, int to) {
	cnt++;
	dfn[u] = cnt;
	seg[cnt] = u;
	top[u] = to;
	if(son[u]==0)return;
	dfs2(son[u], to);
	for (auto v : g[u]) {
		if (v == son[u] || v==fa[u])continue;
		dfs2(v,v);
	}
}

//main
	dfs1(b,0);
	dfs2(b,b);
```



#### 具有的两个性质:

同一条重链的节点dfn序是连续的

同一棵子树的节点dfn序是连续的



#### 修改和查询子树的值

将节点按照dfn序建立一棵线段树，修改和查询就是在头节点x的dfn[x]~dfn[x]+siz[x]-1范围内操作

```c++
void treeadd(int x,int ad){
	add(1,dfn[x],dfn[x]+siz[x]-1,ad);
}
ll treequery(int x){
	return query(1,dfn[x],dfn[x]+siz[x]-1);
}
```



#### 修改和查询一条链上的值

如果此时x和y的top相同，直接修改x~y然后返回，否则的话设dep[top[x]]>dep[top[y]],修改dfn[top[x]]到dfn[x]，然后让x=fa[top[x]]

```c++
void pathadd(int l,int r,int ad){
	while(top[l]!=top[r]){
		if(dep[top[l]]>dep[top[r]])swap(l,r);
		add(1,dfn[top[r]],dfn[r],ad);
		r=fa[top[r]];
	}
	add(1,min(dfn[l],dfn[r]),max(dfn[l],dfn[r]),ad);
}
ll pathquery(int l,int r){
	ll an=0;
	while(top[l]!=top[r]){
		if(dep[top[l]]>dep[top[r]])swap(l,r);
		an=(an+query(1,dfn[top[r]],dfn[r]))%mod;
		r=fa[top[r]];
	}
	return (an+query(1,min(dfn[l],dfn[r]),max(dfn[l],dfn[r])))%mod;
}
```



#### lca查询

```c++
int lca(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]>dep[top[y]])swap(x,y);
		y=fa[top[y]];
	}
	return dfn[x]<dfn[y]?x:y;
}
```



### 边权转化为点权的处理技巧

**把每条边的边权下放到这条边的子节点的点权**

如果要修改一条边的边权要么就修改子节点的点权

如果要修改/查询一条链的边权那么除了lca(x,y)的点权都修改

如果要修改/查询一颗子树的边权那么除了头结点的点权都修改



```c++
void edgepath_add(int u,int v,int w){
	while(top[u]!=top[v]){
		if(dep[top[u]]>dep[top[v]])swap(u,v);
		add(1,dfn[top[v]],dfn[v],w);
		v=fa[top[v]];
	}
	add(1,min(dfn[u],dfn[v])+1,max(dfn[u],dfn[v]),w);
}
void edgetree_add(int x,int ad){
	add(1,dfn[x]+1,dfn[x]+siz[x]-1,ad);
}
```





#  长链剖分（根据儿子的子树高度来决定长儿子的划分）

#### 初始化，需要维护的信息：

**fa,dep,len（以x为头结点树的最大高度）,son（长儿子，子树高度最长的儿子，如果有多个任选其一）,top（所在重链的头结点）,dfn,seg（seg[i]表示dfn序为i的节点，即seg[dfn[i]]=i)**



### o(1)求k级祖先

首先利用树上倍增求出st[u] [p] ，再预处理出两个表：up,down，这个表只有长链的头结点有，up和down的大小都为自己长链的大小，通过dfn序看出可以这个表其实可以整合成一个O(n)长度的表 up/down[u] [k]=up[dfn[u]+k]，还要再预处理出一个表high表示x二进制下最高位的1在哪，high[1]=0 ,high[i]=high[i/2]+1

**流程：** 从u要跳k步首先通过high表和st表跳出二进制下最高位的1步，u=st[u] [high[k],k-=(1<<high[k]),然后让u跳到top[u]，此时只要根据跳多了还是跳少了根据up和down表一步就能跳到目标点

**解释：**一开始通过st表至少跳了k/2步，那么再跳到的top[u]的len[top[u]]一定是大于等于k/2的(根据长链的性质)，所以此时离目标点的距离一定可以通过up或者down到达

**预处理o(nlogn),查询o(1)**

```c++
int n,q,cnt=0;
int st[N+1][M+1];
int fa[N+1],dep[N+1],len[N+1],dfn[N+1],seg[N+1],top[N+1],son[N+1],up[N+1],down[N+1],high[N+1];
void dfs1(int u,int f){
	fa[u]=f;
	dep[u]=dep[f]+1;
	st[u][0]=f;
	for(int i=1;i<=M;i++){
		st[u][i]=st[st[u][i-1]][i-1];
	}
	for(auto v:g[u]){
		if(v==f)continue;
		dfs1(v,u);
		if(len[son[u]]<len[v])son[u]=v;
	}
	len[u]=len[son[u]]+1;
}
void dfs2(int u,int to){
	cnt++;
	dfn[u]=cnt;
	seg[cnt]=u;
	top[u]=to;
	if(son[u]==0)return;
	dfs2(son[u],to);
	for(auto v:g[u]){
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
void pre(){
	high[0]=-1;
	for(int i=1;i<=n;i++)high[i]=high[i/2]+1;
	for(int u=1;u<=n;u++){
		if(top[u]==u){
			for(int i=dfn[u],p=u,q=u,cnt=1;cnt<=len[u];i++,p=fa[p],q=son[q],cnt++){
				up[i]=p;
				down[i]=q;
			}
		}
	}
}
int get_fa(int x,int k){
	if(k==0)return x;
	x=st[x][high[k]];
	k-=(1<<high[k]);
	int diff=k-(dep[x]-dep[top[x]]);
	x=top[x];
	if(diff>=0)x=up[dfn[x]+diff];
	else x=down[dfn[x]-diff];
	return x;
}
```



## 长链剖分优化树上动态规划

一个树形dp问题，假设dp[u] [..]为节点u的dp表，dp表和转移方程和子树高度u有关，那么可以通过长链剖分优化

长链剖分既可以优化时间也可以优化空间

**在长儿子中子节点的信息可以直接继承给父节点，非长儿子子节点的信息暴力合并到长儿子中**，因为每个非长儿子点只有一遍的暴力合并到它的长儿子，所以时间复杂度是o(n)

**核心在于如何确定每个点的dp信息以及dp表从哪里开始**

板子题：[CF1009F Dominant Indices - 洛谷](https://www.luogu.com.cn/problem/CF1009F)

**dp[父] [i]=dp[子] [i-1]**

```c++
int n,cnt=0;
int fa[N+1],dfn[N+1],len[N+1],son[N+1],an[N+1],dp[N+1];
void dfs1(int u,int f){
    fa[u]=f;
    for(auto v:g[u]){
        if(v==f)continue;
        dfs1(v,u);
        if(len[v]>len[son[u]])son[u]=v;
    }
    len[u]=len[son[u]]+1;
}
void dfs2(int u){
    cnt++;
    dfn[u]=cnt;
    dp[dfn[u]]=1;
    if(son[u]!=0){
        dfs2(son[u]);
        an[u]=an[son[u]];
    }
    if(an[u]==0||dp[an[u]]<=dp[dfn[u]])an[u]=dfn[u];
    for(auto v:g[u]){
        if(v==fa[u]||v==son[u])continue;
        dfs2(v);
        for(int i=dfn[u]+1,j=dfn[v],cnt=1;cnt<=len[v];i++,j++,cnt++){
            dp[i]+=dp[j];
            if(dp[i]>dp[an[u]])an[u]=i;
            else if(dp[i]==dp[an[u]]&&i<an[u])an[u]=i;
        }
    }
}
```

如果在同一条长链上那么继承只需要把开头位置后移即可，如果不在同一条长链上那么直接去暴力合并

ps：对于某个点答案也要继承，如果暴力再去扫它的长链上的点，时间复杂度会退化为o(n^2)

