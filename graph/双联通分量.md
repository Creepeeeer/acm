**对于无向图**

**点双连通分量（Vertex-Biconnected Component, 简称 V-BCC）**
 一个极大子图，任意两个点至少有两条点不重复的路径（即删除任意一个点仍然连通）。

**边双连通分量（Edge-Biconnected Component, 简称 E-BCC）**
 一个极大子图，任意两个点至少有两条边不重复的路径（即删除任意一条边仍然连通）。

**一个顶点在只能在一个ebcc中，但可以在多个vbcc中**

## 边双联通分量

#### 方法1：

**首先求出所有的桥，然后再dfs一遍不往桥上走得到的联通分量就是ebcc**

```c++
const int N=5e5,M=2e6;
vector<pii>g[N+1];
vector<int>ebcc[N+1];
int low[N+1],dfn[N+1];
bool is_bridge[M+1],vis_ebcc[N+1];
int n,m,cnt=1,ebcc_cnt=0;
void tarjan(int u,int f){
	dfn[u]=low[u]=cnt++;
	for(auto[v,id]:g[u]){
		if(!dfn[v]){
			tarjan(v,id);
			low[u]=min(low[u],low[v]);
			if(low[v]>dfn[u])is_bridge[id]=true;
		}
		else if(f!=id){
			low[u]=min(low[u],dfn[v]);
		}
	}
}
void dfs(int u){
	vis_ebcc[u]=true;
	ebcc[ebcc_cnt].push_back(u);
	for(auto[v,id]:g[u]){
		if(vis_ebcc[v]||is_bridge[id])continue;
		dfs(v);
	}
}

//main
 for(int i=1;i<=m;i++){
    	int u,v;
    	cin>>u>>v;
    	g[u].push_back({v,i});
    	g[v].push_back({u,i});
    }
    fill(is_bridge,is_bridge+m+1,false);
    fill(vis_ebcc,vis_ebcc+n+1,false);
    for(int i=1;i<=n;i++){
    	if(!dfn[i])tarjan(i,0);
    }
    for(int i=1;i<=n;i++){
    	if(!vis_ebcc[i]){
    		ebcc_cnt++;
    		dfs(i);
    	}
    }
    cout<<ebcc_cnt<<'\n';
    for(int i=1;i<=ebcc_cnt;i++){
    	cout<<ebcc[i].size()<<' ';
    	for(auto x:ebcc[i])cout<<x<<' ';
    	cout<<'\n';
    }
```



#### 方法2：

把无向边看作有向边，过程就和求强联通分量一样

```c++
stack<int>stk;
void tarjan(int u,int f){
	dfn[u]=low[u]=cnt++;
	stk.push(u);
	for(auto[v,id]:g[u]){
		if(!dfn[v]){
			tarjan(v,id);
			low[u]=min(low[u],low[v]);
		}
		else if(f!=id){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		ebcc_cnt++;
		while(stk.top()!=u){
			int x=stk.top();
			stk.pop();
			ebcc[ebcc_cnt].push_back(x);
		}
		ebcc[ebcc_cnt].push_back(u);
		stk.pop();
	}
}
```



## 点双联通分量

先给出两个性质：

1. 两个点双最多只有一个公共点，且一定是割点。
2. 对于一个点双，它在 DFS 搜索树中 dfn 值最小的点一定是割点或者树根。

我们根据第二个性质，分类讨论：

1. 当这个点为割点时，它一定是点双连通分量的根，因为一旦包含它的父节点，他仍然是割点。

2. 当这个点为树根时：
   1. 有两个及以上子树，它是一个割点。
   
   2. 只有一个子树，它是一个点双连通分量的根。
   
   3. 它没有子树，视作一个点双
   
      **一个点可能会在多个vbcc中**

```c++

	vector<int>vbcc[N+1];
	int dfn[N+1],low[N+1];
	int n,m,cnt,vbcc_cnt;
	stack<int>stk;
	void tarjan(int u,int f){
		dfn[u]=low[u]=++cnt;
		stk.push(u);
		if(f==0&&g[u].empty()){
			vbcc_cnt++;
			vbcc[vbcc_cnt].push_back(u);
			return;
		}
		for(auto [v,id]:g[u]){
			if(!dfn[v]){
				tarjan(v,id);
				low[u]=min(low[u],low[v]);
				if(low[v]>=dfn[u]){
					vbcc_cnt++;
					while(stk.top()!=v){//注意弹栈是弹到v而不是u因为u点dfs v之前可能还dfs过一些点，那些点可能和u在同一个vbcc里，如果弹到u就会把这些点也弹出了
						int x=stk.top();
						stk.pop();
						vbcc[vbcc_cnt].push_back(x);
					}
					vbcc[vbcc_cnt].push_back(v);
					stk.pop();
					vbcc[vbcc_cnt].push_back(u);
				}
			}
			else if(id!=f)low[u]=min(low[u],dfn[v]);
		}
	}
```

