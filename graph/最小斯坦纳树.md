### 问题：求k个节点的最小生成树，但是有一些额外节点可以选择

**总时间复杂度是 O(n×$3^k$+m*log*m×$2^k$)**

# Steiner 树：Dreyfus–Wagner 子集 DP

### 流程

目标：在一般带权**无向连通图**中，找到一个**连通子图**把给定端点集合 $S$ 全部连起来，且**边权和最小**。允许使用非端点作为中转（“Steiner 点”）。

由于 $k \le 10$，使用经典的 **Dreyfus–Wagner 子集 DP**。

---

## 定义

令
$$
\mathrm{dp}[M][v]
$$
表示：连接端点子集 $M \subseteq S$ 的最小代价，且该连通子图“收敛于 / 终止在”结点 $v$。

直觉：把所有需要连起来的端点按子集 $M$ 分组，最终的树可以看作若干子树在某个点 $v$ 合并。

---

## 转移（两步）

### 1) 子集合并（只在同一终止点 $v$ 合并）

$$
\mathrm{dp}[M][v] \leftarrow 
\min_{\emptyset \ne M_1 \subset M}
\Big(
  \mathrm{dp}[M_1][v] + \mathrm{dp}[M \setminus M_1][v]
\Big)
$$

含义：两棵覆盖不相交端点集的最优子树在 $v$ 合并。

### 2) 图上松弛（把“终止点”从 $u$ 走到 $v$,类似于一个换根过程）

$$
\mathrm{dp}[M][v] \leftarrow
\min_{u}
\Big(
  \mathrm{dp}[M][u] + \mathrm{dist}[u][v]
\Big)
$$

其中 $\mathrm{dist}$ 是图上任意两点的最短路长度（如用 Dijkstra 预处理或每步多源 Dijkstra 传播）。  
这一步等价于允许我们用**图的最短路径**把“合并点”移动到更合适的位置。

---

## 初始（单端点 $s_i$）

$$
\mathrm{dp}[1 \ll i][v] = \mathrm{dist}[s_i][v]
$$

即覆盖集合只含端点 $s_i$ 时，让“终止点”在任意 $v$，代价就是从 $s_i$ 到 $v$ 的最短路长度（把“终止点在 $s_i$”的状态一次性松到全图）。

---

## 答案

$$
\min_{v}\ \mathrm{dp}[\text{FullMask}][v],
\qquad
\text{FullMask} = (1 \ll k) - 1
$$

---

## 复杂度

常见实现的时间复杂度：
$$
O\!\left(n \cdot 3^k + m \cdot 2^k \log n\right).
$$


板子：

```c++
const int N=100;
vector<pii>g[N+1];
vector<int>nums;
int dp[1<<10][N];
priority_queue<pii,vector<pii>,greater<pii>>pq;
void djstra(int s){
	while(!pq.empty()){
		auto[d,u]=pq.top();
		pq.pop();
		if(d!=dp[s][u])continue;
		for(auto &[v,w]:g[u]){
			if(w+d<dp[s][v]){
				dp[s][v]=w+d;
				pq.push({dp[s][v],v});
			}
		}
	}
}
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){
    	int u,v,w;
    	cin>>u>>v>>w;
    	u--,v--;
    	g[u].push_back({v,w});
    	g[v].push_back({u,w});
    }
    nums.resize(k);
    for(int i=0;i<k;i++){
    	cin>>nums[i];
    	nums[i]--;
    }
    sort(all(nums));
    memset(dp,0x3f,sizeof(dp));
    for(int i=0;i<k;i++)dp[1<<i][nums[i]]=0;
    for(int s=0;s<(1<<k);s++){
    	for(int i=0;i<n;i++){
    		for(int j=s;j>0;j=s&(j-1)){
    			dp[s][i]=min(dp[s][i],dp[j][i]+dp[s^j][i]);
    		}
    	}
    	for(int i=0;i<n;i++){
    		if(dp[s][i]!=inf)pq.push({dp[s][i],i});
    	}
    	djstra(s);
    }
    int an=inf;
    for(int i=0;i<n;i++)an=min(an,dp[(1<<k)-1][i]);
    cout<<an;
```

