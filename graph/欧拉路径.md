1. **欧拉路径定义**：

图中经过所有边**恰好一次**的路径叫**欧拉路径**（也就是一笔画）。如果此路径的**起点**和**终点**相同，则称其为一条**欧拉回路**。

2. **欧拉路径判定（是否存在）**：

- **有向图欧拉路径**：图中**恰好**存在 1 个点出度比入度多 1（这个点即为 **起点** *S*），1 个点入度比出度多 1（这个点即为 **终点** *T*），其余节点出度=入度。
- **有向图欧拉回路**：**所有点**的入度=出度（起点 *S* 和终点 *T* 可以为任意点）。
- **无向图欧拉路径**：图中**恰好**存在 2 个点的度数是**奇数**，其余节点的度数为**偶数**，这两个度数为**奇数**的点即为欧拉路径的 **起点** *S* 和 **终点** *T*。
- **无向图欧拉回路**：**所有点**的度数都是**偶数**（起点 *S* 和终点 *T* 可以为任意点）。

判断有向图欧拉路径

```c++
const int N=1e5;
int n,m;
vector<int>graph[N+1];
int in[N+1];
int out[N+1];
int now[N+1];
int fa[N+1];
stack<int>st;
int find(int x){
	if(fa[x]!=x){
		fa[x]=find(fa[x]);
	}
	return fa[x];
}
void un(int x,int y){
	int fx=find(x);
	int fy=find(y);
	if(fx>fy){
		swap(fx,fy);
		swap(x,y);
	}
	fa[fy]=fx;
}
bool issame(int x,int y){return find(x)==find(y);}
bool connect(){
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=n;i++){
		for(auto v:graph[i])un(i,v);
	}
    for(int i=1;i<=n;i++){
    	if(!issame(i,1))return false;
    }
    return true;
}
void dfs(int u){
	if(graph[u].size()>0)
	{
		for(int i=graph[u][now[u]];now[u]<graph[u].size();i=graph[u][now[u]]){
			now[u]++;
			dfs(i);
		}
	}
	st.push(u);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int u,v;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u>>v;
		graph[u].push_back(v);
		out[u]++;
		in[v]++;
	}
	bool ok=connect();
	int sta=-1,en=-1;
	for(int i=1;i<=n;i++){
		if(abs(in[i]-out[i])>=2){
			ok=false;break;
		}
		else if(in[i]-out[i]==1){
			if(en==-1)en=i;
			else{
				ok=false;break;
			}
		}
		else if(out[i]-in[i]==1){
			if(sta==-1)sta=i;
			else{ok=false;break;}
		}
	}
	if(!ok){
		cout<<"No"<<endl;
	}
	else{
		for(int i=1;i<=n;i++)sort(graph[i].begin(),graph[i].end());
			if(sta!=-1)
			dfs(sta);
		    else dfs(1);
		while(!st.empty()){
			int u=st.top();
			st.pop();
			cout<<u<<' ';
		}
	}
}
```

首先要利用并查集判断图的联通性，然后再一遍深搜，最后要倒序输出，欧拉通路从出度-入度大于一的地方开始dfs，回路的话任选一点（如从一开始即可）；

