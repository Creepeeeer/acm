# 1.链式前向星

```c++
//有n个点m条边
int head[n+1];//head[i]指的是i为出发点的第一条边是第几条边 初始化全为0 后根据插进来的边来更改
//head[i]和to[i]都是第i条边的信息
int next[m+1];//如果next[i]为0终止 储存的是同一开头下一条边的位置
int to[m+1];//指的是该条边指向的位置
//如果边有权值要加value数组
int value[m+1];//指的是该条边的权值
int cnt=1;//记录读进来边的数量 每读一条边cnt++
//初始化
void build(int n){
    fill(head+1,head+n+1,0);
}
//加边
void addedge(int u,int v,int w){
    next[cnt]=head[u];
    to[cnt]=v;
    value[cnt]=w;
    head[u]=cnt++;
}
//便利所有以p开头的边
for(int p=head[temp];p>0;p=next[p]){
    int u=temp;//开头
    int v=to[p];//终点
    int w=value[p];//权值
}
```

# 2.拓扑排序

```c++
//初始化统计每个点入度
vector<int>node[n + 1];
int indegree[n];
fill(indegree + 1, indegree + n + 1, 0);
//每条边 u v w indegree[v]++;
//拓扑
queue<int>qu;
for (int i = 1; i <= n; i++) {
	if (indegree[i] == 0)qu.push(i);
}
while (!qu.empty()) {
	int temp = qu.front();
	qu.pop();
	//遍历所有以temp开头的边入度--，如果入度为0push进qu;
	for (auto x : node[temp]) {
		indegree[x]--;
		if (indegree[x] == 0)qu.push(x);
	}
}
```

ps：出现重边时应该先去重否则会出错

ps:建立边的两个顶点可能不是一类东西
