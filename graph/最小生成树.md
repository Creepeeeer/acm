## 概念

在无向带权图中选择一些边保证整体连通性边权值之和最小，最小生成树可能不止一棵

# 1.Krustal算法（最常用）

1.将所有边从小到大排序

2.如果当前这条边的两个点不在同一个union就连起来否则下一条

3.直到生成了一棵树

code:

```c++
int n, m;
int fa[N + 1];
struct Node{
	int l;
	int r;
	int value;
};
int find(int x) {
	if (x != fa[x]) {
		fa[x] = find(fa[x]);
	}
	return fa[x];
}
bool issame(int x, int y) {
	return find(x) == find(y);
}
void un(int x, int y) {
	int fx = find(x);
	int fy = find(y);
	if (fx < fy) {
		swap(x, y);
		swap(fx, fy);
	}
	fa[fx] = fy;
}
	cin >> n >> m;
	vector<Node>node(m);
	for (int i = 0; i < m; i++) {
		cin >> node[i].l >> node[i].r >> node[i].value;
}
	sort(node.begin(), node.end(), [](Node a, Node b) {return a.value < b.value; });
	iota(fa + 1, fa + n + 1, 1);
	ll sum = 0;
	int siz = 0;
	for (auto x : node) {
		if (siz == n - 1)break;
		if (!issame(x.l, x.r)) {
			un(x.l, x.r);
			sum += x.value;
			siz++;
		}
	}
```

# 2.prim算法

<img src="C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250410192107356.png" alt="image-20250410192107356" style="zoom:80%;" />

```c++
vector<pa>node[N + 1];
int n, m;
struct cmp{
	bool operator()(pa a, pa b) {
		return a.second > b.second;
	}
};
	int u, v, w;
	for (int i = 1; i <= m; i++) {
		cin >> u >> v >> w;
		node[u].push_back({ v,w });
		node[v].push_back({ u,w });
	}
	priority_queue<pa, vector<pa>, cmp>pq;
	vector<bool>vis(n + 1);
	fill(vis.begin(), vis.end(), false);
	pq.push({ 1,0 });
	ll sum = 0;
	int siz = 0;
	while (!pq.empty()) {
		pa temp = pq.top();
		pq.pop();
		int v = temp.first;
		if (!vis[v]) {
			siz++;
			sum += temp.second;
			vis[v] = true;
			for (auto x : node[v]) {
				pq.push(x);
			}
		}
	}

```

