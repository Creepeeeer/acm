# 1.二维数点问题

一开始先给出一些二维坐标系的点 ，离线的给出q个询问，每个询问问(x1,y1)到(x2,y2)区间内的点的个数

做法：可以通过二维前缀和转化为求（1,1）到（x，y）区域内的点的数量，将询问和点排序，对于每个询问（p,q）将小于等于它的点加入统计y的树状数组中（单点修改），由于x已经保证满足，只需要查询树状数组中<=q的点的个数（区间查询）

code

```c++
vector<pa>ta;
vector<int>an;
vector<pa>point;
const int N = 2e6;
int n, m;
int tr[N + 1] = { 0 };
int lowbit(int x) { return x & (-x); }
void update(int x, int d) {
	while (x <= 2 * n) {
		tr[x] += d;
		x += lowbit(x);
	}
}
int query(int x) {
	int an = 0;
	while (x) {
		an += tr[x];
		x -= lowbit(x);
	}
	return an;
}
void addta(int x1, int x2, int y1, int y2) {//要查询的矩形，将四个前缀信息加入
	ta.push_back({ x2,y2 });
	ta.push_back({ x2,y1 - 1 });
	ta.push_back({ x1 - 1,y2 });
	ta.push_back({ x1 - 1,y1 - 1 });
}
int query2(int x, int y) {
	pa temp = { x,y };
	int i = lower_bound(ta.begin(), ta.end(), temp) - ta.begin();
	return an[i];
}
int querypre(int x1, int x2, int y1, int y2) {//得到矩形的块内的数量
	return query2(x2, y2) - query2(x2, y1 - 1) - query2(x1 - 1, y2) + query2(x1 - 1, y1 - 1);
}



	for (int i = 0; i < m; i++)cin >> point[i].first >> point[i].second;
	for (int i = 0; i < m; i++) {
		auto [x, y] = point[i];
		point.push_back({ y,x });
	}
	sort(point.begin(), point.end());
	int q;
	cin >> q;
	vector<pa>qu(q);
	for (int i = 0; i < q; i++)cin >> qu[i].first >> qu[i].second;
	for (auto [c, d] : qu) {
		addta(c, d, 1, c);
		addta(c, d, d, 2 * n);
	}
	sort(ta.begin(), ta.end());
	ta.erase(unique(ta.begin(), ta.end()), ta.end());
	an.resize(ta.size());
	int r = 0;
	for (int i = 0; i < ta.size(); i++) {
		while (r < 2 * m && point[r] <= ta[i]) {
			update(point[r].second, 1);
			r++;
		}
		an[i] = query(ta[i].second);
	}
	for (int i = 0; i < q; i++) {
		auto [c, d] = qu[i];
		int cnt = 0;
		cnt += querypre(c, d, 1, c) + querypre(c, d, d, 2 * n);
		cout << cnt << '\n';
	}
```

