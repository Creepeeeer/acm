# 最长递增子序列

暴力方法o(n2)

优化o(nlogn)

## 1.严格递增

code：

```c++

   int findnum(vector<int>end,int l,int r,int num){
    int m,an=-1;
    while(r>=l){
        m=(l+r)>>1;
        if(end[m]>=num){
            an=m;
            r=m-1;
        }
        else l=m+1;
    }
    return an;
}
        int n=nums.size();
         vector<int>dp(m+1);//此时dp数组也可以省略 答案为r-l+1
        vector<int>end(m+1);//end[i]代表长度为i的递增数组最小的最后一个数
        int l=1,r=1;
        end[1]=nums[0];
        int i,find,num;
        for(i=1;i<n;i++){
            num=findnum(end,l,r,nums[i]);
            if(num==-1)end[++r]=nums[i];
            else end[num]=nums[i];
        }
        return r-l+1;
```

题目链接 [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=problem-list-v2&envId=f4LgKPld)



## 2.非递减子序列

只需要修改二分方法，其他一样

code：

```c++
 int findnum(vector<int>end,int l,int r,int num){
    int m,an=-1;
    while(r>=l){
        m=(l+r)>>1;
        if(end[m]>num){
            an=m;
            r=m-1;
        }
        else l=m+1;
    }
    return an;
}
```



### 最少上升子序列覆盖数

一个序列，把它**划分成几个“严格递减”的子序列**，每个数必须出现在某一个子序列里，并且不能重复。

**做法：**先reverse，维护一个multiset，先插入a[1],每次贪心upper_bound找到比自己大的最小的数，然后删除（如果没有就不删）

然后把a[i]插进去



**一个结论**

**Dilworth 定理** 是偏理论的结论，意思是：

> 在一个偏序集（例如：数字按大小比较）中，最少需要多少个**下降子序列来覆盖**，等于**最长上升子序列的长度**。

反过来也成立：

- 最少**上升子序列数** = 最长**下降子序列长度**



## 最长递增子序列的个数

[673. 最长递增子序列的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/)

首先离散化，然后维护一个pii树状数组tr，tr[i]表示以i为结尾的最长递增子序列长度和个数，从左往右遍历的时候，查询sign-1左边的pii找到最大的以及累加次数，那么此处的pair就是长度+1，个数

