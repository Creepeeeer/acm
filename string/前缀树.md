![image-20250506172741922](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250506172741922.png)

code

```c++
const int N=1e5;
int tr[N][26];
int p[N];
int e[N];
int cnt=1;
void insert(string s){
	int n=s.size();
	int cur=1;
	p[cur]++;
	for(int i=0;i<n;i++){
		int num=s[i]-'a';
		if(tr[cur][num]==0){
			tr[cur][num]=++cnt;
		}
		cur=tr[cur][num];
		p[cur]++;
	}
	e[cur]++;
}
int search(string s){
	int n=s.size();
	int cur=1;
	for(int i=0;i<n;i++){
		int num=s[i]-'a';
		if(tr[cur][num]==0)return 0;
		cur=tr[cur][num];
	}
	return e[cur];
}
int pre(string s){
	int n=s.size();
	int cur=1;
	for(int i=0;i<n;i++){
		int num=s[i]-'a';
		if(tr[cur][num]==0)return 0;
		cur=tr[cur][num];
	}
	return p[cur];
}
void cut(string s){
	if(search(s)>0){
		int cur=1;
		int m=s.size();
		for(int i=0;i<m;i++){
			int num=s[i]-'a';
			if(--p[tr[cur][num]]==0){
				tr[cur][num]=0;
				return;
			}
			cur=tr[cur][num];
		}
		e[cur]--;
	}
}
//ps cut函数的剪枝要防止有路线走到剪枝的后面，以防万一还是写成p[tr[cur][num]]--;
```

ps：遇到数字类 如果数字特别大，tr第二维没必要开特别大，可以将一个数拆开 ，如“9987“可以拆成”9987#“，用‘#’表示一个数字已经结束了，则tr第二维只需要开[10];





### 前缀树的剪枝

https://leetcode.cn/problems/word-search-ii/?envType=problem-list-v2&envId=f4LgKPld

#### 1.将要找的字符串丢进前缀树中，dfs只需要走前缀树中有的路

#### 2.将end数组换成结果的string数组，不需要回溯就可以得到结果

#### 3.把已经找到的结果路径的pass值--，类似delete，剪枝重复的字符串（利用dfs返回值，表示路径上在字典中单词数量）





### **01trie**

把数拆成二进制的形式，然后每一位都只有两个字符：0或1，然后按照trie的方式存下来，以达到节省空间的效果。



[421. 数组中两个数的最大异或值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/)

把每个数的二进制从高到低拆开，放到trie里，然后对于每个数，从它的二进制高位到低位来看，找有没有数使得这一位异或完为1，如果有的话就往那边走，否则的话就往异或完为0的边走

[P4551 最长异或路径 - 洛谷](https://www.luogu.com.cn/problem/P4551)

这个是上一题的强化版，先从点1跑一遍dfn序，然后利用异或的前缀性，x,y之间的异或值为1到x的异或值^1到y的异或值



