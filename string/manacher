**求解字符串的最长回文子串，时间复杂度O(n)**

## 前置：

首先要获得拓展字符串，在back和front位置以及两个字符中间加字符#，整体字符串长度将变为2*n+1**(这一步可以方便偶回文串的计算，不需要虚轴的概念）**

**回文半径数组p：**从某个点开始（包含那个点）向左右两边扩获得回文串，此时的半径长度 。**回文半径-1=最长回文子串长度**

**回文覆盖最右边界r：**前面回文字符串的最右边界+1

**回文中心c:**回文覆盖最右边界的所在字符串的中心，如果r相同c取最左的

拓展回文串的最右端下标/2=原字符串最右端下标/2+1

## 流程：

**1：如果r==i，那么此时得不到加速，以i为中心暴力拓展**

**2.如果r>i,对称点2c-i的回文半径在大半径里面，那么p[i]=p[2c-i]**

**3.如果r>i,对称点2c-i的回文半径在大半径外面，那么p[i]=r-i**

**4.如果r>i,对称点2c-i的回文半径刚好与大半径重合，那么从r位开始接着扩展**



**板子：**

```c++
int manacher(string&s){
	int n=s.size();
	string ss(2*n+1,'#');
	for(int i=1,j=0;j<n;j++,i+=2)ss[i]=s[j];
	n=2*n+1;
	vector<int>p(2*n+1);
	int an=0;
	for(int r=0,c=0,len,i=0;i<n;i++){
		len=r>i?min(r-i,p[2*c-i]):1;
		while(i+len<n&&i-len>=0&&ss[i+len]==ss[i-len])len++;
		if(i+len>r){
			r=i+len;
			c=i;
		}
		p[i]=len;
		an=max(an,len);
	}
	return an-1;
}
```

