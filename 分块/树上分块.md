## 重链序列分块

[P6177 Count on a tree II/【模板】树分块 - 洛谷](https://www.luogu.com.cn/problem/P6177)

将整棵树重链剖分，然后基于dfn序将序列进行分块，每个块用一个bitset来存，一条链上重链数量为$logn$，每次查询一条重链为$\sqrt n$

,分为左散+中间+右散，单次查询是$\sqrt n logn$的

```c++
const int N=4e4,B=1e3;
int a[N+1];
vector<int>g[N+1];
int n,q;
int blen,bnum,bi[N+1],bl[B+1],br[B+1];
bitset<N>bt[B+1];
int dfn[N+1],seg[N+1],fa[N+1],son[N+1],top[N+1],siz[N+1],dep[N+1],dfn_cnt;
vector<int>nums;
void build(){
	blen=sqrt(30*n);
	bnum=(n+blen-1)/blen;
	for(int i=1;i<=n;i++){
		bi[i]=1+(i-1)/blen;
	}
	for(int i=1;i<=bnum;i++){
		bl[i]=1+(i-1)*blen;
		br[i]=min(n,i*blen);
	}
	for(int i=1;i<=bnum;i++){
		for(int j=bl[i];j<=br[i];j++)
		bt[i][a[seg[j]]]=1;
	}
}
bitset<N>query(int l,int r){
	bitset<N>an;
	if(bi[l]==bi[r]){
		for(int i=l;i<=r;i++)an[a[seg[i]]]=1;
	}
	else{
		for(int i=l;i<=br[bi[l]];i++)an[a[seg[i]]]=1;
		for(int i=bl[bi[r]];i<=r;i++)an[a[seg[i]]]=1;
		for(int i=bi[l]+1;i<=bi[r]-1;i++)an|=bt[i];
	}
	return an;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;i++){
    	int x;
    	cin>>x;
    	a[i]=x;
    	nums.push_back(x);
    }
    sort(all(nums));
    nums.erase(unique(all(nums)),nums.end());
    for(int i=1;i<=n;i++){
    	a[i]=lower_bound(all(nums),a[i])-nums.begin();
    }
    for(int i=1;i<=n-1;i++){
    	int u,v;
    	cin>>u>>v;
    	g[u].push_back(v);
    	g[v].push_back(u);
    }
    dfs1(1,0);//dfs1和dfs2同重链剖分
    dfs2(1,1);
    build();
    int an=0;
    while(q--){
    	int x,y;
    	cin>>x>>y;
    	x^=an;
    	if(x>y)swap(x,y);
    	bitset<N>te;
    	while(top[x]!=top[y]){
    		if(dep[top[x]]>dep[top[y]])swap(x,y);
    		te|=query(dfn[top[y]],dfn[y]);
    		y=fa[top[y]];
    	}
    	te|=query(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));
    	an=te.count();
    	cout<<an<<'\n';
    }
    return 0;
```



## 树上随机撒点

树上随机选$\sqrt n$个关键点，非关键点到它最近的关键点，两个相邻的关键点，期望距离都是$\sqrt n$

非关键点到它最近的关键点之间视为散块，关键点到关键点之间视为整块，类似于之前的整块散块结合

**关键点需要维护：**

1.它是第几个关键点 2.向上跳到的关键点，3.下到上的位图

marknum表示关键点的数量，vis[i]表示第i号节点是否已经是关键点了，用于随机撒的过程，nodek[k]=i表示第k个关键点是i,node[i]=k表示第i号节点是第k个关键点，如果k为0表示不是，up[i]=j表示第i号节点是关键点，它向上跳的最近的关键点是第j号节点，bt[k]表示第k个关键点及其上面点（没到下一个关键点）组成的位图

类似于分块，对于整块就利用储存的位图，对于散块就去暴力计算，还需要倍增求lca

```c++
const int N=1e5,M=3e4,P=17,B=5e3;
int a[N+1],st[N+1][P+1],dep[N+1],nodek[B+1],node[N+1],up[N+1];
bitset<M>bt[B+1];
bool vis[N+1];
vector<int>g[N+1];
int n,m,c,maxdep,blen,bnum;
bitset<M>te;
//dfs和lca同树上倍增
void build(){
	dfs(1,0);
	maxdep=(int)log2(maxdep);
	blen=sqrt(n*10);
	bnum=(n+blen-1)/blen;
	fill(vis,vis+n+1,false);
	for(int i=1;i<=bnum;i++){
		int x;
		do{
			x=rd(1,n);
		}while(vis[x]);
		nodek[i]=x;
		node[x]=i;
		vis[x]=true;
	}
	for(int i=1;i<=bnum;i++){
		int x=nodek[i];
		bt[i][a[x]]=1;
		x=st[x][0];
		while(x){
			if(node[x]){
				up[nodek[i]]=x;
				break;
			}
			bt[i][a[x]]=1;
			x=st[x][0];
		}
	}
}
void query(int x,int y){
	while(node[x]==0&&x!=y){
		te[a[x]]=1;
		x=st[x][0];
	}
	while(up[x]>0&&dep[up[x]]>dep[y]){
		te|=bt[node[x]];
		x=up[x];
	}
	while(x!=y){
		te[a[x]]=1;
		x=st[x][0];
	}
	te[a[y]]=1;
}
```

