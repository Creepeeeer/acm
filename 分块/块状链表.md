# 块状链表

**适用于区间增删，区间移动的题目**

**实现上，不用动态链表实现，利用栈pool进行块编号分配和回收，本质上是个静态数组**

**规定块的容量为2*根号n,每个块里字符的数量<=容量**

**插入操作时：先分裂成左右两块，在两块之间插入若干新块**

**删除操作时：分裂最左块和最右块，删除最左和最右和中间**

**进行完插入和删除操作后，遍历检查相邻块大小，如果内容和小于容量就合并**

```c++
const int N = 4e6, blen = 4e3, bnum = 2e3;
struct node {
    int siz, nxt = -1;
    string s;
}b[bnum + 1];
vector<int>use;
pii find(int x) {
    if (x == 0)return { 0,0 };
    int sum = 0, cur = b[0].nxt, cur2 = 0;
    while (sum + b[cur].siz < x) {
        sum += b[cur].siz;
        cur = b[cur].nxt;
    }
    cur2 = x - sum;
    return { cur,cur2 };
}
void split(int bi, int bi2) {
    if (bi == 0 || bi2 == 0)return;
    int te = use.back();
    use.pop_back();
    b[te].nxt = b[bi].nxt;
    b[bi].nxt = te;
    b[te].siz = b[bi].siz - bi2;
    b[bi].siz = bi2;
    b[te].s = b[bi].s.substr(bi2);
    b[bi].s = b[bi].s.substr(0, bi2);
}
void insert(int bi, string s) {
    int n = s.size(), cur = 0;
    while (n) {
        int te = use.back();
        use.pop_back();
        b[te].siz = min(n, blen);
        b[te].s = s.substr(cur, b[te].siz);
        cur += b[te].siz;
        n -= b[te].siz;
        b[te].nxt = b[bi].nxt;
        b[bi].nxt = te;
        bi = te;
    }
}
void merge(int cur) {
    while (cur != -1) {
        while (b[cur].nxt != -1 && b[cur].siz + b[b[cur].nxt].siz <= blen) {
            int te = b[cur].nxt;
            b[cur].s += b[te].s;
            b[cur].siz += b[te].siz;
            b[cur].nxt = b[te].nxt;
            use.push_back(te);
        }
        cur = b[cur].nxt;
    }
}
void erase(int bi, int n) {
    int te = b[bi].nxt;
    int sum = 0;
    while (sum + b[te].siz < n) {
        sum += b[te].siz;
        use.push_back(te);
        te = b[te].nxt;
    }
    split(te, n - sum);
    use.push_back(te);
    te = b[te].nxt;
    b[bi].nxt = te;
}
void print(int bi, int bi2, int n) {
    int te = b[bi].siz - bi2;
    if (n <= te) {
        cout << b[bi].s.substr(bi2, n);
    }
    else {
        cout << b[bi].s.substr(bi2);
        n -= te;
        bi = b[bi].nxt;
        while (n) {
            int num = min(n, b[bi].siz);
            cout << b[bi].s.substr(0, num);
            n -= num;
            bi = b[bi].nxt;
        }
    }
}
```

