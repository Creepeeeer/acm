# 单调栈

## 适用条件

1.每个位置都求当前位置左侧和右侧比当前位置小，且距离最近的位置在哪(栈为大压小)，最底元素是最小的

2.或每个位置都求当前位置左侧和右侧比当前位置大，且距离最近的位置在哪（栈为小压大）



下面以情况一说明：

code:

```c++
   stack<int>t;
int pre[n];//储存左侧数
int last[n];//储存右侧数
int a[n];
// pre/last=-1表示不存在
    for(i=0;i<n;i++){
        cin>>a[i];
    }
t.push(0);
for(i=1;i<n;i++){
if(a[i]>a[t.top()]){
   t.push(i);
}
else{
while(!t.empty()&&a[i]<=a[t.top()])
{temp=t.top();
t.pop();
if(!t.empty()){
    pre[temp]=t.top();
}
else pre[temp]=-1;
last[temp]=i;
}
t.push(i);
    }
}
//如果没有重复数字 左右侧都是严格小于 不需要考虑下面代码
//如果有 如果不加下面代码 左侧是小于右侧是小于等于
//      加了的话是严格小于 应根据题目要求选择
while(!t.empty()){
    temp=t.top();
    t.pop();
    if(!t.empty()){
        pre[temp]=t.top();
    }
    else pre[temp]=-1;
    last[temp]=-1;
}
```



**补充**

如果两侧都不要严格递增或者递减，上面那个代码只能保证一侧

```c++
stack<int>st;
    st.push(1);
    for (int i = 2; i <= n; i++) {
        while (!st.empty() && a[i] >= a[st.top()]) {
            int temp = st.top();
            st.pop();
            if (l[temp] == 0) {
                if (st.empty())l[temp] = 0;
                else l[temp] = st.top();
            }
            r[temp] = i;
            if (a[i] == a[temp] && l[i] == 0)l[i] = temp;
        }
        st.push(i);
    }
    while (!st.empty()) {
        int temp = st.top();
        st.pop();
        if (l[temp] == 0) {
            if (st.empty())l[temp] = 0;
            else l[temp] = st.top();
        }
         r[temp] = n + 1;
    }
```



# 单调队列

## 主要用法

可以维护一个滑动的窗口（窗口大小不一定固定）的最大值（小压大）和最小值（大压小）

板子题 [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)

## 主题思想

头部维持最值优势，尾部维持新旧优势，新元素一定有新旧优势，又新最值又好可以直接淘汰前面又旧最值又差的，扩展时又淘汰了头部过期的元素
