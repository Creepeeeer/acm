## 扁平化+小接大（非递归）

code：

```c++
int fa[N+1];
int si[N+1];
int find(int x){
    vector<int>ve;
    while(fa[x]!=x){
        ve.push_back(x);
        x=fa[x];
    }
    while(!ve.empty()){
        fa[ve.back()]=x;
        ve.pop_back();
    }
    return x;
}
bool issame(int x,int y){
    return find(x)==find(y);
}
void un(int x,int y){
    int fx=find(x);
    int fy=find(y);
    if(si[fx]>=si[fy]){
        fa[fy]=fx;
        si[fx]+=si[fy];
    }
    else 
    {fa[fx]=fy;
    si[fy]+=si[fx];
    }
}
void build(int x){
    for(int i=1;i<=x;i++){
        fa[i]=i;
        si[i]=1;
    }
}

```



## 扁平化+递归

```c++
int fa[N+1];
int find(int x){
    if(x!=fa[x]){
        fa[x]=find(fa[x]);
    }
    return fa[x];//此处不能改为x因为此处是逐层返回
}
bool issame(int x,int y){
    return find(x)==find(y);
}
void un(int x,int y){
   fa[find(x)]=find(y);
}
void build(int x){
    for(int i=1;i<=x;i++){
        fa[i]=i;
    }
}
```

难题

[765. 情侣牵手 - 力扣（LeetCode）](https://leetcode.cn/problems/couples-holding-hands/description/?envType=problem-list-v2&envId=f4LgKPld)

该题难在得出结论次数等于总数量减并查集数量

##### 并查集信息也可以去除

[2092. 找出知晓秘密的所有专家 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-people-with-secret/description/?envType=problem-list-v2&envId=f4LgKPld)

在该题中，如果合并完后如果不知晓秘密，则可以通过fa[x]=x;从而去除合并信息

##### 维护树上子树的最大最小值

先对值进行从小到大排序

用并查集合并时，**总是从节点值小的点往节点值大的点合并**，这样可以保证连通块的代表元的节点值是最大的。

根据乘法原理，把这两个连通块内节点个数相乘，加到答案中。

e.g

[2421. 好路径的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-good-paths/description/?envType=problem-list-v2&envId=f4LgKPld)

[Problem - 915F - Codeforces](https://codeforces.com/problemset/problem/915/F)

```c++
	void build(int n) {
	fill(siz+1, siz + n+1, 1);
	iota(fa+1, fa + n+1, 1);
}
	build(n);
	sort(ve.begin()+1,ve.end());
	for (int i = 1; i<=n; i++) {
		int va = ve[i].first;
		int num = ve[i].second;
		int fnum = find(num);
		for (auto x : node[num]) {
			int fx = find(x);
			if (fx==fnum||a[x] > a[num])continue;
			fa[fx] = fnum;
			summax += (ll)a[num] * siz[fnum] * siz[fx];
			siz[fnum] += siz[fx];
		}
	}
```

