## 猫树

普通线段树的建树过程是$O(n)$的，查询单次是$O(logn)$的

猫树解决的问题是**树不存在修改操作**，并且查询的信息是**能被左右两个区间的信息合并的**，**可支持在线查询**，建树过程是$O(nlogn)$,单次查询是O(1)的

原理：

在查询 [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 这段区间的信息和的时候，将线段树树上代表 [𝑙,𝑙]![[l,l]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的节点和代表 [𝑟,𝑟]![[r,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 这段区间的节点在线段树上的 LCA 求出来，设这个节点 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 代表的区间为 [𝐿,𝑅]![[L,R]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)，我们会发现一些非常有趣的性质：

1. [𝐿,𝑅]![[L,R]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 这个区间一定包含 [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。显然，因为它既是 𝑙![l](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的祖先又是 𝑟![r](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的祖先。
2. [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 这个区间一定跨越 [𝐿,𝑅]![[L,R]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的中点。由于 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 是 𝑙![l](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 和 𝑟![r](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的 LCA，这意味着 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的左儿子是 𝑙![l](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的祖先而不是 𝑟![r](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的祖先，𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的右儿子是 𝑟![r](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的祖先而不是 𝑙![l](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的祖先。因此，𝑙![l](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 一定在 [𝐿,mid]![[L,\mathit{mid}]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 这个区间内，𝑟![r](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 一定在 (mid,𝑅] 这个区间内。

**实现：**

不同于传统线段树在这个节点里只保留 [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的和，我们在这个节点里面额外保存 (𝑙,mid]的后缀和数组和 (mid,𝑟]的前缀和数组。

这样的话建树的复杂度为 𝑇(𝑛) =2𝑇(𝑛/2) +𝑂(𝑛) =𝑂(𝑛log⁡𝑛)![T(n)=2T(n/2)+O(n)=O(n\log{n})](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 同理空间复杂度也从原来的 𝑂(𝑛)![O(n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 变成了 𝑂(𝑛log⁡𝑛)![O(n\log{n})](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。

如果我们询问的区间是 [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 那么我们把代表 [𝑙,𝑙]![[l,l]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的节点和代表 [𝑟,𝑟]![[r,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的节点的 LCA 求出来，记为 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。

根据刚才的两个性质，𝑙,𝑟![l,r](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 在 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 所包含的区间之内并且一定跨越了 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的中点。

这意味这一个非常关键的事实是我们可以使用 𝑝![p](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 里面的前缀和数组和后缀和数组，将 [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 拆成 [𝑙,mid] +(mid,𝑟]从而拼出来 [𝑙,𝑟]![[l,r]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 这个区间。

我们将这个序列补成 2的整次幂，然后建线段树，此时我们发现节点[l,l]和节点[r,r]的lca的编号就是两个节点二进制编号的最长公共前缀 LCP。可发现发现在 𝑥![x](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 和 𝑦![y](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的二进制下 `lcp(x,y)=x>>digits[x^y]`。（其中 `digits[x]` 表示二进制下 𝑥![x](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的位数，即 ⌊$log2(𝑥)$⌋ +1)



例题:

[P6240 好吃的题目 - 洛谷](https://www.luogu.com.cn/problem/P6240)

区间1->n,每个位置是一个物品价值为v，重量为w，q次询问，求只选l.....r之间物品的01背包最大价值

给你两个区间的01背包，合并两个01背包，计算 $\max\limits_{i=0}^{s} F1[i] + F2[s - i]$ 即可。这样仅需 $O(t)$。

总时间复杂度$O(ntlogn+qt)$，空间复杂度是$O(ntlogn)$

```c++
pii ob[N+1];
int n,q;
vector<vector<int>>pre[8*N+1],suf[8*N+1];
int num[N+1];//num[i]表示点i在猫树中的编号
inline int digit(int x){
    return x==0?x:32-__builtin_clz(x);
}//digit(i)表示i的二进制的位数=floor(log2(i))+1
struct tree{
    int l,r;
}tr[4*N+1];
void build(int i,int l,int r){
    if(l>n)return;
    tr[i].l=l;
    tr[i].r=r;
    int m=(l+r)>>1;
    suf[i].resize(m-l+2);
    pre[i].resize(r-m+1);
    for(int j=0;j<suf[i].size();j++)suf[i][j].resize(201);
    for(int j=0;j<pre[i].size();j++)pre[i][j].resize(201);
    for(int j=m+1;j<=min(r,n);j++){
        auto&[w,v]=ob[j];
        for(int k=0;k<=200;k++){
            pre[i][j-m][k]=pre[i][j-m-1][k];
            if(k>0)pre[i][j-m][k]=max(pre[i][j-m][k],pre[i][j-m][k-1]);
            if(k>=w&&j<=n)pre[i][j-m][k]=max(pre[i][j-m][k],pre[i][j-m-1][k-w]+v);
        }
    }
    for(int j=min(n,m);j>=l;j--){
        auto&[w,v]=ob[j];
        for(int k=0;k<=200;k++){
            suf[i][m-j+1][k]=suf[i][m-j][k];
            if(k>0)
            suf[i][m-j+1][k]=max(suf[i][m-j+1][k],suf[i][m-j+1][k-1]);
            if(k>=w&&j<=n)
            suf[i][m-j+1][k]=max(suf[i][m-j+1][k],suf[i][m-j][k-w]+v);
        }
    }
    if(l==r){
        num[l]=i;
        return;
    }
    else{
        build(i<<1,l,m);
        build(i<<1|1,m+1,r);
    }
}
//main
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>ob[i].first;
    }
    for(int i=1;i<=n;i++){
        cin>>ob[i].second;
    }
    build(1,1,1<<((int)ceil(log2(n))));
    while(q--){
        int l,r,t;
        cin>>l>>r>>t;
        int lca=num[l]>>digit(num[l]^num[r]);
        int an=0;
        int m=(tr[lca].l+tr[lca].r)>>1;
        auto&ve1=suf[lca][m+1-l],&ve2=pre[lca][r-m];
        for(int i=0;i<=t;i++){
            an=max(an,ve1[i]+ve2[t-i]);
        }
        cout<<an<<'\n';
    }
```



## 猫树分治

其实刚才那个题使用猫树是解决不了的因为空间会爆

猫树分治总时间复杂度$O(ntlogn+qt)$（和猫树一样），但空间复杂度是$O(nt)$，

猫树可以**在线**，但是猫树分治是**离线查询**，二者都不可以修改树

**实现：**

因为是离线所以我们只需要一个二维的dp表就可以，并且已经不需要将点补全为2的幂次

带着l,r和满足当前区间的Q走，将Q分为三类：[L..m-1),[m+1....r],跨越m的，建出本轮[l...r]的dp表（直接在原来表上覆盖即可），第一类和第二类的继续递归下去，第三类的利用本轮产生的dp表直接解决

```c++
int n,q;
int an[M+1];
struct Q
{
    int l,r,k,id;
};
pii ob[N+1];
int pre[N+1][T+1],suf[N+1][T+1];
void solve(int l,int r,vector<Q>&ve){
    if(l==r){
        for(auto&[ql,qr,k,id]:ve){
            if(k>=ob[l].first)an[id]=ob[l].second;
        }
        return;
    }
    int m=(l+r)>>1;
    for(int i=m;i<=r;i++){
        for(int j=0;j<=T;j++){
            pre[i][j]=0;
        }
    }
    for(int i=m+1;i<=r;i++){
        auto&[w,v]=ob[i];
        for(int j=1;j<=T;j++){
            pre[i][j]=max(pre[i-1][j],pre[i][j-1]);
            if(j>=w)pre[i][j]=max(pre[i][j],pre[i-1][j-w]+v);
        }
    }
    for(int i=m+1;i>=l;i--){
        for(int j=0;j<=T;j++){
            suf[i][j]=0;
        }
    }
    for(int i=m;i>=l;i--){
        auto&[w,v]=ob[i];
        for(int j=1;j<=T;j++){
            suf[i][j]=max(suf[i+1][j],suf[i][j-1]);
            if(j>=w)suf[i][j]=max(suf[i][j],suf[i+1][j-w]+v);
        }
    }
    vector<Q>ve1,ve2;
    for(auto&x:ve){
        auto[l,r,k,id]=x;
        if(r<m)ve1.push_back(x);
        else if(l>=m+1)ve2.push_back(x);
        else{
            for(int j=0;j<=k;j++){
                an[id]=max(an[id],pre[r][j]+suf[l][k-j]);
            }
        }
    }
    solve(l,m,ve1);
    solve(m+1,r,ve2);
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>ob[i].first;
    for(int i=1;i<=n;i++)cin>>ob[i].second;
    vector<Q>ve(q);
    for(int i=0;i<q;i++){
        cin>>ve[i].l>>ve[i].r>>ve[i].k;
        ve[i].id=i;
    }
    solve(1,n,ve);
    for(int i=0;i<q;i++){
        cout<<an[i]<<'\n';
    }
```

