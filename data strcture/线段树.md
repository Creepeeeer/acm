#### 如果不需要范围修改的话就不需要懒更新了

## 板子：

```c++
struct tree
{
	int l,r,ad,sum;
}tr[4*N+1];
void up(int i){
	tr[i].sum=tr[i<<1].sum+tr[i<<1|1].sum;
}
void lazy(int i,int ad){
	tr[i].ad+=ad;
	tr[i].sum+=(tr[i].r-tr[i].l+1)*ad;
}
void down(int i){
	if(tr[i].l!=tr[i].r&&tr[i].ad!=0){
		lazy(i<<1,tr[i].ad);
		lazy(i<<1|1,tr[i].ad);
		tr[i].ad=0;
	}
}
void build(int i,int l,int r){
	tr[i].l=l;
	tr[i].r=r;
	if(l==r){
		tr[i].sum=a[l];
		return;
	}
	int m=(l+r)>>1;
	build(i<<1,l,m);
	build(i<<1|1,m+1,r);
	up(i);
}
void add(int i,int ql,int qr,int ad){
	if(tr[i].l>=ql&&tr[i].r<=qr){
		tr[i].ad+=ad;
		tr[i].sum+=(tr[i].r-tr[i].l+1)*ad;
		return;
	}
	if(qr<tr[i].l||ql>tr[i].r)return;
	down(i);
	int m=(tr[i].l+tr[i].r)>>1;
	if(ql<=m)add(i<<1,ql,qr,ad);
	if(qr>=m+1)add(i<<1|1,ql,qr,ad);
	up(i);
}
int query(int i,int ql,int qr){
	int an=0;
	if(tr[i].l>=ql&&tr[i].r<=qr){
		return tr[i].sum;
	}
	if (qr < tr[i].l || ql > tr[i].r) return 0;
	down(i);
	int m=(tr[i].l+tr[i].r)>>1;
	if(ql<=m)an+=query(i<<1,ql,qr);
	if(qr>=m+1)an+=query(i<<1|1,ql,qr);
	return an;
}
```



**懒更新机制只适用于有单调性的和线性可分配的**

[CF1791F Range Update Point Query - 洛谷](https://www.luogu.com.cn/problem/CF1791F)

这个题的操作让数字变为数位和，不具有单调性，如99和100操作后变为18,1

