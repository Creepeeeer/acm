## 线段树的最值操作和区间修改

给你一个arr，支持一下三种操作

1 l , r , x,把区间arr[l,r]的数都更新为$min(x,a[i])$

2 l r 查询区间的最大值

3 l r 查询区间的累加和 

4 l r x 把范围 l~r都+x

**此时线段树需要维护的信息有 累加和sum，区间最大值maxn,区间最大值的个数cnt，区间次大值sema（严格小于最大值），如果没有设置为负无穷** 

**对于取min操作**

如果区间maxn<=x，那么直接返回

如果x>sema&&x<=maxn,可以懒更新，maxn=x,sum-=cnt*(maxn-x)

如果x<=sema 那么直接暴力向下递归 

时间复杂度是$O(mlogn)$的

证明：对于线段树的每个节点，如果它的maxn!=它的父亲的maxn，那么给这个点打一个标记，标记的数量是$O(n)$的，每次setmin 经过的点的标记都删除，并且没有标记的点之后不会再访问了，每次删除标记的复杂度最多是$O(logn)$=树高

对于操作4：

**此时势能增加量不会超过$(logn)^2$**，因为修改区间，只会给从1到tr[i].l=tr[i].r=l所在节点以及1到r所在节点打上标记，标记个数为$2*logn$，又删除每个标记时间复杂度最差是$O(logn)$

## 区间历史最值

[P6242 【模板】线段树 3（区间最值操作、区间历史最值） - 洛谷](https://www.luogu.com.cn/problem/P6242)

除了一个长度为n的数组a，还给了一个辅助数组b=a，每次操作完，令$bi=max(bi,ai)$

此时还要额外储存三个信息，maxhistory(历史的最大值)，maxtop(最大值的历史最大maxadd)，othtop(除了最大值的历史最大maxoth)

```c++
struct tree{
	int l,r,maxn,maxhis,maxadd,othadd,maxaddtop,othaddtop,cntmax,sema;
	ll sum;
}tr[(N<<2)+1];
void up(int i){
	tr[i].sum=tr[i<<1].sum+tr[i<<1|1].sum;
	tr[i].maxhis=max(tr[i<<1].maxhis,tr[i<<1|1].maxhis);
	tr[i].maxn=max(tr[i<<1].maxn,tr[i<<1|1].maxn);
	if(tr[i<<1].maxn>tr[i<<1|1].maxn){
		tr[i].cntmax=tr[i<<1].cntmax;
		tr[i].sema=max(tr[i<<1].sema,tr[i<<1|1].maxn);
	}
	else if(tr[i<<1].maxn<tr[i<<1|1].maxn){
		tr[i].cntmax=tr[i<<1|1].cntmax;
		tr[i].sema=max(tr[i<<1|1].sema,tr[i<<1].maxn);
	}
	else{
		tr[i].cntmax=tr[i<<1].cntmax+tr[i<<1|1].cntmax;
		tr[i].sema=max(tr[i<<1].sema,tr[i<<1|1].sema);
	}
}
void lazy(int i,int maxadd,int othadd,int maxaddtop,int othaddtop){
	tr[i].maxhis=max(tr[i].maxhis,tr[i].maxn+maxaddtop);
	tr[i].maxaddtop=max(tr[i].maxaddtop,tr[i].maxadd+maxaddtop);
	tr[i].othaddtop=max(tr[i].othaddtop,tr[i].othadd+othaddtop);
	tr[i].maxadd+=maxadd;
	tr[i].othadd+=othadd;
	tr[i].sum+=1ll*maxadd*tr[i].cntmax+1ll*othadd*(tr[i].r-tr[i].l+1-tr[i].cntmax);
	tr[i].maxn+=maxadd;
	tr[i].sema+=tr[i].sema==-inf?0:othadd;
}
void down(int i){
	int maxn=max(tr[i<<1].maxn,tr[i<<1|1].maxn);
	if(tr[i<<1].maxn==maxn)
		lazy(i<<1,tr[i].maxadd,tr[i].othadd,tr[i].maxaddtop,tr[i].othaddtop);
	else lazy(i<<1,tr[i].othadd,tr[i].othadd,tr[i].othaddtop,tr[i].othaddtop);
	if(tr[i<<1|1].maxn==maxn)
		lazy(i<<1|1,tr[i].maxadd,tr[i].othadd,tr[i].maxaddtop,tr[i].othaddtop);
	else lazy(i<<1|1,tr[i].othadd,tr[i].othadd,tr[i].othaddtop,tr[i].othaddtop);
	tr[i].maxadd=tr[i].othadd=tr[i].maxaddtop=tr[i].othaddtop=0;
}
void build(int i,int l,int r){
	tr[i].l=l;
	tr[i].r=r;
	if(l==r){
		tr[i].sum=tr[i].maxn=tr[i].maxhis=a[l];
		tr[i].sema=-inf;
		tr[i].cntmax=1;
		return;
	}
	int m=(l+r)>>1;
	build(i<<1,l,m);
	build(i<<1|1,m+1,r);
	up(i);
}
void add(int i,int l,int r,int ad){
	if(tr[i].l>=l&&tr[i].r<=r){
		lazy(i,ad,ad,ad,ad);
		return;
	}
	if(r<tr[i].l||l>tr[i].r)return;
	down(i);
	int m=(tr[i].l+tr[i].r)>>1;
	if(l<=m)add(i<<1,l,r,ad);
	if(r>=m+1)add(i<<1|1,l,r,ad);
	up(i);
}
void setmin(int i,int l,int r,int x){
	if(tr[i].maxn<=x)return;
	if(tr[i].l>=l&&tr[i].r<=r&&tr[i].sema<x){
		lazy(i,x-tr[i].maxn,0,x-tr[i].maxn,0);
		return;
	}	
	down(i);
	int m=(tr[i].l+tr[i].r)>>1;
	if(l<=m)setmin(i<<1,l,r,x);
	if(r>=m+1)setmin(i<<1|1,l,r,x);
	up(i);
}
ll querysum(int i,int l,int r){
	if(tr[i].l>=l&&tr[i].r<=r){
		return tr[i].sum;
	}
	if(r<tr[i].l||l>tr[i].r)return 0;
	down(i);
	ll an=0;
	int m=(tr[i].l+tr[i].r)>>1;
	if(l<=m)an+=querysum(i<<1,l,r);
	if(r>=m+1)an+=querysum(i<<1|1,l,r);
	return an;
}
int querymax(int i,int l,int r){
	if(tr[i].l>=l&&tr[i].r<=r){
		return tr[i].maxn;
	}
	if(r<tr[i].l||l>tr[i].r)return -inf;
	down(i);
	int an=-inf;
	int m=(tr[i].l+tr[i].r)>>1;
	if(l<=m)an=max(an,querymax(i<<1,l,r));
	if(r>=m+1)an=max(an,querymax(i<<1|1,l,r));
	return an;
}
int querymaxhis(int i,int l,int r){
	if(tr[i].l>=l&&tr[i].r<=r){
		return tr[i].maxhis;
	}
	if(r<tr[i].l||l>tr[i].r)return -inf;
	down(i);
	int an=-inf;
	int m=(tr[i].l+tr[i].r)>>1;
	if(l<=m)an=max(an,querymaxhis(i<<1,l,r));
	if(r>=m+1)an=max(an,querymaxhis(i<<1|1,l,r));
	return an;
}
```



[P10639 BZOJ4695 最佳女选手 - 洛谷](https://www.luogu.com.cn/problem/P10639)

这个题多了setmax和querymin ，但是要注意边界

```c++
void lazy(int i,int addmax,int addoth,int addmin){
	tr[i].addmax+=addmax;
	tr[i].addoth+=addoth;
	tr[i].addmin+=addmin;
	if(tr[i].maxn==tr[i].semi){
		if(tr[i].sema!=-lnf)
		tr[i].sema+=addmin;
		if(tr[i].semi!=lnf)
		tr[i].semi+=addmax;
	}
	if(tr[i].maxn==tr[i].minn){
		tr[i].minn+=addmax;
		tr[i].maxn+=addmin;
	}
	tr[i].maxn+=addmax+addoth;
	tr[i].minn+=addmin+addoth;
	tr[i].sum+=addmax*tr[i].cntmax+addoth*(tr[i].r-tr[i].l+1)+addmin*tr[i].cntmin;
	tr[i].sema+=tr[i].sema==-inf?0:addoth;
	tr[i].semi+=tr[i].semi==0?0:addoth;
}
```

