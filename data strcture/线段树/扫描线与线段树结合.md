[P5490 【模板】扫描线 & 矩形面积并 - 洛谷](https://www.luogu.com.cn/problem/P5490)

先离散化，然后滚动x轴对y轴建线段树

对于点x1,y1,x2,y2 在x1对y1-y2 +1，在x2对y1-y2 -1

此时线段树不需要懒信息了，因为+1与-1是对应的不需要把懒信息下发

```c++
struct tree
{
    int l, r,len,sum,cnt;
}tr[4 * N + 1];
void up(int i) {
    if(tr[i].cnt==0)
    tr[i].sum=tr[i<<1].sum+tr[i<<1|1].sum;
    else tr[i].sum=tr[i].len;
}
void build(int i, int l, int r) {
    tr[i].l = l;
    tr[i].r = r;
    if (l == r) {
        tr[i].len = nums2[l] - nums2[l - 1];
        return;
    }
    int m = (l + r) >> 1;
    build(i << 1, l, m);
    build(i << 1 | 1, m + 1, r);
    tr[i].len = tr[i << 1].len + tr[i << 1 | 1].len;
    up(i);
}
void add(int i, int ql, int qr, int ad) {
    if (tr[i].l >= ql && tr[i].r <= qr) {
        tr[i].cnt+=ad;
        if(tr[i].cnt>0)tr[i].sum=tr[i].len;
        else if(tr[i].l==tr[i].r)tr[i].sum=0;
        else tr[i].sum=tr[i<<1].sum+tr[i<<1|1].sum;
        return;
    }
    if (qr<tr[i].l || ql>tr[i].r)return;
    int m = (tr[i].l + tr[i].r) >> 1;
    if (ql <= m)add(i << 1, ql, qr, ad);
    if (qr >= m + 1)add(i << 1 | 1, ql, qr, ad);
    up(i);
}
```



[P1856 [IOI 1998 / USACO5.5\] 矩形周长 Picture - 洛谷](https://www.luogu.com.cn/problem/P1856)

进行两次扫描线，扫描x轴的时候此时得到的答案为$abs(last-tr[1].sum)$,但此时要注意如果同一个x位置应该先处理+1的算一次答案然后再算一次-1的再算一次答案

hack数据：2 1 1 2 2 2 2 3 3

