经典模型：

连续1的子串长度：给你一个01串，再给你多个区间，每次查询这个区间内最长的全为1的子串

**此时线段树需要维护的信息:** 连续1的最长子串长度len，连续1的最长前缀长度pre，连续1的最长后缀长度suf

$len[i]=max(len[i<<1],len[i<<1|1],suf[i<<1]+pre[i<<1|1])$

如果i<<1全为1，$pre[i]=pre[i<<1]+pre[i<<1|1]$,否则$pre[i]=pre[i<<1]$

同理  如果i<<1|1全为1，$suf[i]=suf[i<<1]+suf[i<<1|1]$,否则$suf[i]=suf[i<<1|1]$

```c++
struct tree
{
    int l,r,ad,pre,suf,len;
}tr[4*N+1];
struct node{
int  pre,len,suf;
};
void up(int i){
    tr[i].len=max({tr[i<<1].len,tr[i<<1|1].len,tr[i<<1].suf+tr[i<<1|1].pre});
    tr[i].pre=(tr[i<<1].len==tr[i<<1].r-tr[i<<1].l+1)?tr[i<<1].pre+tr[i<<1|1].pre:tr[i<<1].pre;
    tr[i].suf=(tr[i<<1|1].len==tr[i<<1|1].r-tr[i<<1|1].l+1)?tr[i<<1].suf+tr[i<<1|1].suf:tr[i<<1|1].suf; 
}
void lazy(int i,int ad){
    tr[i].ad=ad;
    tr[i].len=tr[i].pre=tr[i].suf=(ad==1?tr[i].r-tr[i].l+1:0);
}
void down(int i){
    if(tr[i].l!=tr[i].r&&tr[i].ad!=0){
        lazy(i<<1,tr[i].ad);
        lazy(i<<1|1,tr[i].ad);
        tr[i].ad=0;
    }
}
void build(int i,int l,int r){
    tr[i].l=l;
    tr[i].r=r;
    if(l==r){
        tr[i].pre=tr[i].suf=tr[i].len=1;
        return;
    }
    int m=(l+r)>>1;
    build(i<<1,l,m);
    build(i<<1|1,m+1,r);
    up(i);
}
void add(int i,int ql,int qr,int ad){
    if(tr[i].l>=ql&&tr[i].r<=qr){
        tr[i].ad=ad;
        tr[i].len=tr[i].pre=tr[i].suf=(ad==1?tr[i].r-tr[i].l+1:0);
        return;
    }
    if(qr<tr[i].l||ql>tr[i].r)return;
    down(i);
    int m=(tr[i].l+tr[i].r)>>1;
    if(ql<=m)add(i<<1,ql,qr,ad);
    if(qr>=m+1)add(i<<1|1,ql,qr,ad);
    up(i);
}
node query(int i,int ql,int qr){
    if(tr[i].l>=ql&&tr[i].r<=qr){
        return {tr[i].pre,tr[i].len,tr[i].suf};
    }
    down(i);
    int m=(tr[i].l+tr[i].r)>>1;
    if(qr<=m) return query(i<<1,ql,qr);
    else if(ql>=m+1) return query(i<<1|1,ql,qr);
    else{
        node x=query(i<<1,ql,qr),y=query(i<<1|1,ql,qr);
        node z;
        z.len=max({x.len,y.len,x.suf+y.pre});
        z.pre=tr[i<<1].r-max(ql,tr[i<<1].l)+1==x.pre?x.pre+y.pre:x.pre;
        z.suf=min(qr,tr[i<<1|1].r)-tr[i<<1|1].l+1==y.suf?x.suf+y.suf:y.suf;
        return z;
    }
}
```

