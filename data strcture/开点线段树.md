**适用的范围：**需要支持的范围很大但是实际操作的次数不大

**此时使用的空间约为$2mlogn$**,适当调大即可

可以支持很大的范围，一开始不为每个范围都分配空间

当真的需要开辟左侧右侧的空间时，再临时申请 

```c++
struct tree{
	int l,r,ad,sum;
}tr[N+1];
int cnt=1;
void up(int i,int l,int r){
	tr[i].sum=tr[l].sum+tr[r].sum;
}
void lazy(int i,int len,int ad){
	tr[i].ad+=ad;
	tr[i].sum+=len*ad;
}
void down(int i,int llen,int rlen){
	if(tr[i].ad!=0){
		if(!tr[i].l){
			tr[i].l=++cnt;
		}
		if(!tr[i].r){
			tr[i].r=++cnt;
		}
		lazy(tr[i].l,llen,tr[i].ad);
		lazy(tr[i].r,rlen,tr[i].ad);
		tr[i].ad=0;
	}
}
void add(int i,int l,int r,int ql,int qr,int ad){
	if(ql<=l&&qr>=r){
		lazy(i,r-l+1,ad);
		return;
	}
	int m=(l+r)>>1;
	down(i,m-l+1,r-m);
	if(ql<=m){
		if(!tr[i].l)tr[i].l=++cnt;
		add(tr[i].l,l,m,ql,qr,ad);
	}
	if(qr>=m+1){
		if(!tr[i].r)tr[i].r=++cnt;
		add(tr[i].r,m+1,r,ql,qr,ad);
	}
	up(i,tr[i].l,tr[i].r);
}
int query(int i,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r)return tr[i].sum;
	if(qr<l||ql>r)return 0;
	int an=0,m=(l+r)>>1;
	down(i,m-l+1,r-m);
	if(ql<=m&&tr[i].l)an+=query(tr[i].l,l,m,ql,qr);
	if(qr>=m+1&&tr[i].r)an+=query(tr[i].r,m+1,r,ql,qr);
	return an;
}

//main
    if(op==1){
    int l,r,ad;
    cin>>l>>r>>ad;
    add(1,1,n,l,r,ad);
    }
    else{
    int l,r;
    cin>>l>>r;
    cout<<query(1,1,n,l,r)<<'\n';
    }
```

