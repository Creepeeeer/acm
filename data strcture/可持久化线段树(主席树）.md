## 单点修改单点查询

[P3919 【模板】可持久化线段树 1（可持久化数组） - 洛谷](https://www.luogu.com.cn/problem/P3919)

root[i]存的是第i号版本的头结点，每次如果要修改的话 因为是单点修改，只会改变一条链$O(logn)$的点，此时新生成一个节点，把所有信息复用之前的节点，然后再去修改

```c++
const int N=1e6;
int a[N+1];
int root[23*N+1];
struct tree{
	int l,r,val;
}tr[23*N+1];
int trcnt;
int build(int l,int r){
	int cur=++trcnt;
	tr[cur].l=l,tr[cur].r=r;
	if(l==r){
		tr[cur].val=a[l];
		return cur;
	}
	int m=(l+r)>>1;
	tr[cur].l=build(l,m);
	tr[cur].r=build(m+1,r);
	return cur;
}
int add(int x,int ad,int l,int r,int fa){
	int cur=++trcnt;
	tr[cur].l=tr[fa].l;
	tr[cur].r=tr[fa].r;
	tr[cur].val=tr[fa].val;
	if(l==r){
		tr[cur].val=ad;
		return cur;
	}
	int m=(l+r)>>1;
	if(x<=m)tr[cur].l=add(x,ad,l,m,tr[cur].l);
	else tr[cur].r=add(x,ad,m+1,r,tr[cur].r);
	return cur;
}
int query(int x,int l,int r,int cur){
	if(l==r)return tr[cur].val;
	int m=(l+r)>>1;
	if(x<=m)return query(x,l,m,tr[cur].l);
	else return query(x,m+1,r,tr[cur].r);
}
//main
 root[0]=build(1,n);
	for(int i=1;i<=q;i++){
		int v,op,p;
		cin>>v>>op>>p;
		if(op==1){
			int ad;
			cin>>ad;
			root[i]=add(p,ad,1,n,root[v]);
		}
		else{
			root[i]=root[v];
			cout<<query(p,1,n,root[i])<<'\n';
		}
	}
```



## 单点修改范围查询

[P3834 【模板】可持久化线段树 2 - 洛谷](https://www.luogu.com.cn/problem/P3834)

打印l-r第k小的数

先将值域离散化得到sorted数组，线段树有$sorted.size()$个节点，每个节点存储的是=sorted[i]的点的个数，再建立n个版本，第i个版本存储的是原数组下标1-i范围内的sorted数组的个数

对于查询 l,r,k我们需要版本l-1和版本r，到达一个节点此时值域的范围为ql-qr，如果$版本r:num[ql-qm]-版本l-1:num[ql-qm]>k$那说明要找的点在左侧,否则要找的点在右侧并且k-=diff(刚才num的差值)



```c++
const int N=2e5;
vector<int>sorted;
int a[N+1];
int root[N+1];
struct tree{
	int l,r,siz;
}tr[23*N+1];
int trcnt;
int build(int l,int r){
	int cur=++trcnt;
	if(l==r);
	else{
		int m=(l+r)>>1;
		tr[cur].l=build(l,m);
		tr[cur].r=build(m+1,r);
	}
	return cur;
}
int add(int x,int ad,int l,int r,int fa){
	int cur=++trcnt;
	tr[cur].l=tr[fa].l;
	tr[cur].r=tr[fa].r;
	tr[cur].siz=tr[fa].siz+1;
	if(l==r);
	else{
		int m=(l+r)>>1;
		if(x<=m)tr[cur].l=add(x,ad,l,m,tr[cur].l);
		else tr[cur].r=add(x,ad,m+1,r,tr[cur].r);
	}
	return cur;
}
int query(int k,int cur1,int cur2,int l,int r){
	if(l==r)return l;
	int diff=tr[tr[cur2].l].siz-tr[tr[cur1].l].siz;
	int m=(l+r)>>1;
	if(diff>=k){
		return query(k,tr[cur1].l,tr[cur2].l,l,m);
	}
	else{
		return query(k-diff,tr[cur1].r,tr[cur2].r,m+1,r);
	}
}

//main
 for(int i=1;i<=n;i++){
    	int x;
    	cin>>x;
    	a[i]=x;
    	sorted.push_back(x);
    }
    sort(all(sorted));
    sorted.erase(unique(all(sorted)),sorted.end());
    int m=sorted.size();
    sorted.insert(sorted.begin(),-1);
    root[0]=build(1,m);
    for(int i=1;i<=n;i++){
    	int num=lower_bound(all(sorted),a[i])-sorted.begin();
    	root[i]=add(num,1,1,m,root[i-1]);
    }
    while(q--){
    	int l,r,k;
    	cin>>l>>r>>k;
    	cout<<sorted[query(k,root[l-1],root[r],1,m)]<<'\n';
    }
```

[Problem - 5919](https://acm.hdu.edu.cn/showproblem.php?pid=5919)

给一个长度为n的序列，每次给l,r，将l->r范围内每个值第一次出现的位置拿出来，求len/2位置的值

从右向左遍历原数组建不同版本的树，线段树长度和原数组等长，如果i是此时版本最左的y=a[i]的位置，那么线段树在i位置+1，在上一个位置-1，此时查询l-r,就查询l版本1-r或者l-r范围内1的个数，再在树上找到精确位置，如果左孩子的sum>=k那么往左找，否则往右并且把sum-k

[P4137 Rmq Problem / mex - 洛谷](https://www.luogu.com.cn/problem/P4137)

给一个长度为n的序列，每次给l,r，求l-r范围内权值的mex

从右向左建立版本，维护值域线段树，点i的值表示val=i的最左下标，区间如果这个范围有最左为0那么为0，否则取子节点的max，对于一个查询，利用l版本的在树上找，如果左树的值>r那么往左找，否则往右找

[P3899 [湖南集训\] 更为厉害 - 洛谷](https://www.luogu.com.cn/problem/P3899)

还是类似求l-r第k大，此时dfn[u]版本要从dfn[u]-1推过来，线段树位置为k的地方维护此时树高为k的子树的大小之和

## 范围修改

 ### 经典方法实现

需要懒更新机制但是仿照单点修改的可持久化线段树，来到一个节点的时候都新建节点并且clone出原来那个节点的信息，如果此时懒信息要下发，那么左右孩子都要新建来接收懒信息以保证老节点的信息不改变

建立最初线段树空间$O(4N)$,建立n个版本的线段树空间$O(nlogn)$,m次查询空间$O(mlogn)$

```c++
int root[100*N+1];
struct tree{
    int l,r,ad;
    ll sum;
}tr[100*N+1];
int trcnt;
void up(int i){
    tr[i].sum=tr[tr[i].l].sum+tr[tr[i].r].sum;
}
int clone(int i){
    int cur=++trcnt;
    tr[cur].sum=tr[i].sum;
    tr[cur].l=tr[i].l;
    tr[cur].r=tr[i].r;
    tr[cur].ad=tr[i].ad;
    return cur;
}
void lazy(int cur,int len,int ad){
    tr[cur].sum+=1ll*len*ad;
    tr[cur].ad+=ad;
}
void down(int i,int llen,int rlen){
    if(tr[i].ad!=0){
        tr[i].l=clone(tr[i].l);
        tr[i].r=clone(tr[i].r);
        lazy(tr[i].l,llen,tr[i].ad);
        lazy(tr[i].r,rlen,tr[i].ad);
        tr[i].ad=0;
    }
}
int build(int l,int r){
    int cur=++trcnt;
    if(l==r)tr[cur].sum=a[l];
    else{
        int m=(l+r)>>1;
        tr[cur].l=build(l,m);
        tr[cur].r=build(m+1,r);
        up(cur);
    }
    return cur;
}
int add(int jl,int jr,int l,int r,int ad,int fa){
    int cur=clone(fa);
    if(jl<=l&&jr>=r){
        lazy(cur,r-l+1,ad);
    }
    else{
        int m=(l+r)>>1;
        down(cur,m-l+1,r-m);
        if(jl<=m)tr[cur].l=add(jl,jr,l,m,ad,tr[cur].l);
        if(jr>=m+1)tr[cur].r=add(jl,jr,m+1,r,ad,tr[cur].r);
        up(cur);
    }
    return cur;
}
ll query(int jl,int jr,int l,int r,int cur){
    if(jl<=l&&jr>=r){
        return tr[cur].sum;
    }
    int m=(l+r)>>1;
    down(cur,m-l+1,r-m);
    ll an=0;
    if(jl<=m)an+=query(jl,jr,l,m,tr[cur].l);
    if(jr>=m+1)an+=query(jl,jr,m+1,r,tr[cur].r);
    return an;
}
```



### 标记永久化

**比起经典方法更节省空间**

**但只适用于修改和查询都有可叠加性**（如范围加一个数和求范围sum）

不适用于如范围重置和查询最大值和最小值

此时懒更新信息不再往下发，修改除非$jl<=l$&&$jr>=r$才修改ad信息，其他的直接修改sum

对于查询除非$jl<=l$&&$jr>=r$才加sum信息，其他的只增加ad信息

此时的空间消耗变为$O(4n+nlogn)$（因为没了懒更新机制下发的新建节点）

```
int a[N+1];
int root[N+1];
struct tree{
	int l,r,ad;
	ll sum;
}tr[30*N+1];
int trcnt;
int build(int l,int r){
	int cur=++trcnt;
	if(l==r)tr[cur].sum=a[l];
	else{
		int m=(l+r)>>1;
		tr[cur].l=build(l,m);
		tr[cur].r=build(m+1,r);
		tr[cur].sum=tr[tr[cur].l].sum+tr[tr[cur].r].sum;
	}
	return cur;
}
int add(int jl,int jr,int ad,int l,int r,int fa){
	int cur=++trcnt;
	tr[cur].l=tr[fa].l;
	tr[cur].r=tr[fa].r;
	tr[cur].ad=tr[fa].ad;
	tr[cur].sum=tr[fa].sum;
	tr[cur].sum+=1ll*ad*(min(r,jr)-max(l,jl)+1);
	if(jl<=l&&jr>=r){
		tr[cur].ad+=ad;
	}
	else{
		int m=(l+r)>>1;
		if(jl<=m)tr[cur].l=add(jl,jr,ad,l,m,tr[cur].l);
		if(jr>=m+1)tr[cur].r=add(jl,jr,ad,m+1,r,tr[cur].r);
	}
	return cur;
}
ll query(int jl,int jr,int l,int r,int cur){
	ll an=1ll*(min(jr,r)-max(jl,l)+1)*tr[cur].ad;
	if(jl<=l&&jr>=r){
		return tr[cur].sum;
	}
	int m=(l+r)>>1;
	if(jl<=m)an+=query(jl,jr,l,m,tr[cur].l);
	if(jr>=m+1)an+=query(jl,jr,m+1,r,tr[cur].r);
	return an;
}
```

