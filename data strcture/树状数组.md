**注意下标要从1开始**

## 一维

### 单点修改区间查询

```c++
int lowbit(int x){return x&-x;}
void addtree(int x,int ad){
	while(x<=n){
		tr[x]+=ad;
		x+=lowbit(x);
	}
}
int querytree(int x){
	int an=0;
	while(x){
		an+=tr[x];
		x-=lowbit(x);
	}
	return an;
}
int query(int l,int r){
	return querytree(r)-querytree(l-1);
}
```



### 区间修改单点查询

```c++
int lowbit(int x){return x&-x;}
void addtree(int x,int ad){
	while(x<=n){
		tr[x]+=ad;
		x+=lowbit(x);
	}
}
int querytree(int x){
	int an=0;
	while(x){
		an+=tr[x];
		x-=lowbit(x);
	}
	return an;
}
void add(int l,int r,int ad){
	addtree(l,ad);
	addtree(r+1,-ad);
}

//main
for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
    	addtree(i,a[i]-a[i-1]);
    }
```



### 区间修改区间查询

![image-20250819105824797](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20250819105824797.png)

```c++
int tr[N+1];
int tr1[N+1];
int lowbit(int x){return x&-x;}
void addtree(int x,int ad){
	for(int i=x;i<=n;i+=lowbit(i)){
		tr[i]+=ad;
		tr1[i]+=x*ad;
	}
}
int querytree(int x){
	int an=0;
	for(int i=x;i>0;i-=lowebit(i)){
		an+=(x+1)*tr[i]-tr1[i];
	}
	return an;
}
void add(int l,int r,int ad){
	addtree(l,ad);
	addtree(r+1,-ad);
}
int query(int l,int r){
	return querytree(r)-query(l-1);
}
```



## 二维

### 单点修改区间查询

```c++
ll tr[N+1][M+1];

int lowbit(int x){ return x & -x; }

void addtree(int x, int y, ll ad){
    for(int i=x;i<=n;i+=lowbit(i))
        for(int j=y;j<=m;j+=lowbit(j))
            tr[i][j]+=ad;
}
ll querytree(int x, int y){
    ll an=0;
    for(int i=x;i>0;i-=lowbit(i))
        for(int j=y;j>0;j-=lowbit(j))
            an+=tr[i][j];
    return an;
}

// 矩形和 (x1,y1)..(x2,y2)
ll query(int x1,int y1,int x2,int y2){
    return  querytree(x2,y2)
          - querytree(x1-1,y2)
          - querytree(x2,y1-1)
          + querytree(x1-1,y1-1);
}
```



### 区间修改单点查询

此时修改是根据二维差分，修改(x,y)的值相当于修改(x,y)->(n,m)这个矩形范围内的值

```c++
ll tr[N+1][M+1];

int lowbit(int x){ return x & -x; }

void addtree(int x, int y, long long ad){
    for(int i=x;i<=n;i+=lowbit(i))
        for(int j=y;j<=m;j+=lowbit(j))
            tr[i][j]+=ad;
}
ll querytree(int x, int y){
    ll an=0;
    for(int i=x;i>0;i-=lowbit(i))
        for(int j=y;j>0;j-=lowbit(j))
            an+=tr[i][j];
    return an;
}
void add(int x1,int y1,int x2,int y2,long long ad){
    addtree(x1, y1, ad);
    if(y2+1<=m) addtree(x1, y2+1, -ad);
    if(x2+1<=n) addtree(x2+1, y1, -ad);
    if(x2+1<=n && y2+1<=m) addtree(x2+1, y2+1, ad);
}

```



### 区间修改区间查询

```c++
ll tr1[N+2][M+2]; // 存 ad
ll tr2[N+2][M+2]; // 存 y*ad
ll tr3[N+2][M+2]; // 存 x*ad
ll tr4[N+2][M+2]; // 存 x*y*ad

int lowbit(int x){ return x & -x; }

void addtree(int x, int y, ll ad){
	for(int i=x;i<=n;i+=lowbit(i)){
		for(int j=y;j<=m;j+=lowbit(j)){
			tr1[i][j] += ad;
			tr2[i][j] += 1ll*y*ad;
			tr3[i][j] += 1ll*x*ad;
			tr4[i][j] += 1ll*x*y*ad;
		}
	}
}

// 矩形 [x1..x2][y1..y2] 加 ad
void add(int x1, int y1, int x2, int y2, ll ad){
	addtree(x1, y1, ad);
	if(x2+1<=n)     addtree(x2+1, y1, -ad);
	if(y2+1<=m)     addtree(x1, y2+1, -ad);
	if(x2+1<=n && y2+1<=m) addtree(x2+1, y2+1, ad);
}

// 前缀 (1..x,1..y) 的总和
ll querytree(int x, int y){
	ll an = 0;
	for(int i=x;i>0;i-=lowbit(i)){
		for(int j=y;j>0;j-=lowbit(j)){
			an += 1ll*(x+1)*(y+1)*tr1[i][j]
			    - 1ll*(x+1)*tr2[i][j]
			    - 1ll*(y+1)*tr3[i][j]
			    + tr4[i][j];
		}
	}
	return an;
}

// 矩形和 (x1,y1)..(x2,y2)
ll query(int x1, int y1, int x2, int y2){
	return  querytree(x2, y2)
	      - querytree(x1-1, y2)
	      - querytree(x2, y1-1)
	      + querytree(x1-1, y1-1);
}
```

