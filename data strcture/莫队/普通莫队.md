**原理**

查询任务由[jobl,jobr]描述

查询任务可以通过滑动窗口[winl,winr]来更新窗口内的信息

**查询任务需要可以离线**，把查询任务进行排序，然后依次处理，时间复杂度是$O(n \sqrt n)$，（假设q与n同阶）

**任务的经典排序策略**：

先把原数组1...n分块，对于两个[jobl,jobr]来说，如果jobl所在块不同那么按照块号升序，否则按照jobr升序

```c++
bool cmp(query&x,query&y){
	if(bi[x.l]!=bi[y.l])return bi[x.l]<bi[y.l];
	else return x.r<y.r;
}
```

**任务的奇偶排序策略**：

如果两个query的jobl所在块不同那么按照块号排序，否则如果jobl的块号为奇按jobr升序，为偶按jobr降序

```c++
bool cmp(query&x,query&y){
	if(bi[x.l]!=bi[y.l])return bi[x.l]<bi[y.l];
	else if(bi[x.l]&1){
		return x.r<y.r;
	}
	else return x.r>y.r;
}
```

**滑动窗口**

```c++
	int ql=1,qr=0,re=0;
	for(auto&[l,r,id]:qy){
		while(qr<r){
			cnt[a[++qr]]++;
			if(cnt[a[qr]]==1)re++;
		}
		while(ql>l){
			cnt[a[--ql]]++;
			if(cnt[a[ql]]==1)re++;
		}
		while(qr>r){
			cnt[a[qr--]]--;
			if(cnt[a[qr+1]]==0)re--;
		}
		while(ql<l){
			cnt[a[ql++]]--;
			if(cnt[a[ql-1]]==0)re--;
		}
		an[id]=re;
	}
```

