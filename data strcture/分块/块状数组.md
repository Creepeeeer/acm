# 块状数组

### 原理

假设数据规模为n,块的大小和块的数量都是根号n规模

分块维护信息时，散块信息暴力维护，整块信息维护lazy就可以

进行区间修改和区间查询的时候，只要操作左散块和右散块和中间整块

### 适用场景

区间不可合并的信息，线段树等结构难以维护，分块往往容易

**建块的过程**

```c++
int blen,bnum,n;
int bi[N+1],bl[M+1],br[M+1];
void build(){
	blen=sqrt(n);
	bnum=(n+blen-1)/blen;
	for(int i=1;i<=n;i++)bi[i]=(i+blen-1)/blen;
	for(int i=1;i<=bnum;i++){
		bl[i]=(i-1)*blen+1;
		br[i]=min(i*blen,n);
	}
}
```

板子题

[SP18185 GIVEAWAY - Give Away - 洛谷](https://www.luogu.com.cn/problem/SP18185)

a为原数组，b为在块里排序的数组，对于查询：如果不是整块就暴力查询，复杂度根号n,如果是整块就在排序后的数组二分找

对于修改，先在a中修改后再把a赋值给b让b重新排序

```c++
void add(int x,int ad){
	a[x]=ad;
	int l=bl[bi[x]],r=br[bi[x]];
	for(int i=l;i<=r;i++)b[i]=a[i];
	sort(b+l,b+r+1);
}
int query(int l,int r,int x){
	int an=0;
	if(bi[l]==bi[r]){
		for(int i=l;i<=r;i++){
			if(a[i]>=x)an++;
		}
	}
	else{
		for(int i=l;i<=br[bi[l]];i++){
			if(a[i]>=x)an++;
		}
		for(int i=bl[bi[r]];i<=r;i++){
			if(a[i]>=x)an++;
		}
		for(int i=bi[l]+1;i<=bi[r]-1;i++){
			int l=bl[i],r=br[i];
			an+=find(l,r,x)-l+1;
		}
	}
	return an;
}
    for(int i=1;i<=bnum;i++){
    	sort(b+bl[i],b+br[i]+1);
    }
```



[P4168 [Violet\] 蒲公英 - 洛谷](https://www.luogu.com.cn/problem/P4168)

需要维护两个信息，freq[i] [j]表示前i个块中j颜色词频，mode[i] [j]表示第i个块到第j个块的众数是哪个数

mode[i] [j]可以通过mode[i] [j-1]以及第j块中的数来加工

 计算答案的时候可以先得到中间整块的众数，再去暴力找左右散块中出现的数，看这些数能不能成为众数



[P5048 [Ynoi2019 模拟赛\] Yuno loves sqrt technology III - 洛谷](https://www.luogu.com.cn/problem/P5048)

上个题的妙妙优化，空间被限制了只能开O(n)空间，保留上面的mode，意义改为第i个块到第j个块的众数的个数

对于某个左右散块加中间整块，首先an=mode[l] [r]，对于某个数暴力取考虑an+1在不在范围之内，如果在an++接着在考虑an+1在不在范围之内，这种操作的时间复杂度有单调性是O(n)的


