下面给你一份**通用、好用、可直接拷贝**的 C++ 快读快写模板，并配一份“怎么用”的简明说明。模板分两档：

- A 档（推荐）：基于 `fread/fwrite` 的超快 IO（比赛/大数据量）
- B 档（简洁）：基于 `getchar_unlocked/putchar_unlocked`（代码短、也很快；Windows 上没有 `_unlocked` 时可用 `getchar/putchar` 代替）

------

# A 档：`fread/fwrite` 超快 IO 模板（推荐）

```cpp
#pragma once
#include <bits/stdc++.h>
struct FastIn {
    static const size_t BUFSIZE = 1 << 20;
    char buf[BUFSIZE];
    size_t idx = 0, len = 0;

    inline char nextChar() {
        if (idx >= len) {
            len = fread(buf, 1, BUFSIZE, stdin);
            idx = 0;
            if (!len) return 0;
        }
        return buf[idx++];
    }
    inline void skipBlanks() {
        char c;
        while ((c = nextChar()) && (c <= ' ')) {}
        if (c) idx--;
    }

    template<class T>
    inline bool readInt(T &out) {
        skipBlanks();
        char c = nextChar();
        if (!c) return false;
        int sgn = 1;
        if (c == '-') { sgn = -1; c = nextChar(); }
        T x = 0;
        for (; c >= '0' && c <= '9'; c = nextChar()) x = x * 10 + (c - '0');
        out = x * sgn;
        return true;
    }

    inline bool readString(std::string &s) {
        skipBlanks();
        char c = nextChar();
        if (!c) return false;
        s.clear();
        for (; c > ' '; c = nextChar()) s.push_back(c);
        return true;
    }
    inline bool readLine(std::string &s) {
        s.clear();
        char c = nextChar();
        if (!c) return false;
        while (c == '\r') c = nextChar();
        while (c && c != '\n') { s.push_back(c); c = nextChar(); }
        return true;
    }
};

struct FastOut {
    static const size_t BUFSIZE = 1 << 20;
    char buf[BUFSIZE];
    size_t idx = 0;
    ~FastOut() { flush(); }

    inline void flush() {
        if (idx) { fwrite(buf, 1, idx, stdout); idx = 0; }
    }
    inline void putChar(char c) {
        if (idx >= BUFSIZE) flush();
        buf[idx++] = c;
    }
    template<class T>
    inline void writeInt(T x, char endc = '\n') {
        if (x == 0) { putChar('0'); putChar(endc); return; }
        if (x < 0) { putChar('-'); x = -x; }
        char s[24]; int n = 0;
        while (x) { s[n++] = char('0' + (x % 10)); x /= 10; }
        while (n--) putChar(s[n]);
        putChar(endc);
    }
    inline void writeString(const std::string &s, char endc = '\n') {
        for (char c : s) putChar(c);
        putChar(endc);
    }
};
```

## 怎么用（A 档）

```cpp
#include <bits/stdc++.h>
#include "FastIO.h"
using namespace std;

int main() {
    ios::sync_with_stdio(false); // 可保留
    cin.tie(nullptr);            // 但不使用 cin/cout

    FastIn in;
    FastOut out;

    int n, m;
    in.readInt(n);
    in.readInt(m);

    vector<int> a(n+1);
    for (int i = 1; i <= n; ++i) in.readInt(a[i]);

    long long ans = 0;
    while (m--) {
        int l, r; in.readInt(l); in.readInt(r);
        ans += r - l + 1;
    }
    out.writeInt(ans); // 输出并自动换行
    // 程序结束时 FastOut 析构会自动 flush()
    return 0;
}
```

### 常用 API 对照

- `in.readInt(x)`：读 `int/long long` 等整型（模板支持带符号/无符号）
- `in.readString(s)`：读一个**不含空白**的 token
- `in.readLine(s)`：读一整行（含空格），行尾不带 `\n`
- `out.writeInt(x)`：写整数 + `\n`
- `out.writeInt(x, ' ')`：写整数 + 空格
- `out.writeString(s)`：写字符串 + `\n`
- `out.putChar(c)`：写单个字符
- `out.flush()`：手动冲刷缓冲（一般不需要，析构会自动冲刷）

------

# B 档：`getchar_unlocked/putchar_unlocked` 精简款

> Linux/BSD 上有 `_unlocked`；Windows/MSVC 通常只有 `getchar/putchar`，可以把 `_unlocked` 去掉也可用（略慢）。

```cpp
inline int gc() {
#ifdef _WIN32
    return getchar();
#else
    return getchar_unlocked();
#endif
}

template<class T>
inline bool readInt(T &out) {
    int c = gc();
    if (c == EOF) return false;
    while (c <= ' ' && c != EOF) c = gc();
    int sgn = 1;
    if (c == '-') { sgn = -1; c = gc(); }
    T x = 0;
    for (; c >= '0' && c <= '9'; c = gc()) x = x * 10 + (c - '0');
    out = x * sgn;
    return true;
}

inline void pc(int c) {
#ifdef _WIN32
    putchar(c);
#else
    putchar_unlocked(c);
#endif
}

template<class T>
inline void writeInt(T x, char endc = '\n') {
    if (x == 0) { pc('0'); pc(endc); return; }
    if (x < 0) { pc('-'); x = -x; }
    char s[24]; int n = 0;
    while (x) { s[n++] = char('0' + (x % 10)); x /= 10; }
    while (n--) pc(s[n]);
    pc(endc);
}
```

使用方法与 A 档类似，直接在你的 `main.cpp` 里粘贴即可。

------

## 小贴士与易错点

1. **不要混用**
    用了快 IO 后，尽量不要再用 `cin/cout/printf/scanf` 混杂读取输出（尤其是 `cin`）。实在要混用，至少 `cout.flush()` 或 `fflush(stdout)` 控制顺序，但建议完全不用。
2. **换行与空格**
    `writeInt(x, ' ')` 输出后**不会**自动换行；最后一项再输出 `'\n'`。
3. **长整型**
    `readInt<long long>(xll);` 或 `long long x; readInt(x);` 都可以。`writeInt` 同理。
4. **字符串输入**

- 读 token 用 `readString(s)`，会跳过前导空白。
- 读整行用 `readLine(s)`，适合读含空格的内容；注意它在行尾不含 `\n`。

1. **性能建议**

- A 档 1MB 缓冲基本足够，数据更大可酌情增大。
- 对超大量输出，尽量减少 `writeInt` 调用次数（能批量写就批量写）。

1. **Windows 下**

- B 档没有 `getchar_unlocked/putchar_unlocked` 时，会自动退化为 `getchar/putchar`，依然可用但稍慢。
- A 档 `fread/fwrite` 完全跨平台，优先选用。

------

## 快速接入到你的题解

把 **A 档 `FastIO.h`** 存成头文件，然后在你的项目里：

```cpp
#include "FastIO.h"

FastIn in; FastOut out;
// 把所有 cin >> x; 换成 in.readInt(x);
// 把 cout << x << '\n'; 换成 out.writeInt(x);
```

如果你懒得建头文件，也可以直接把 A 档代码粘到最上面用。

需要我把你刚才那份代码替换成“使用 A 档 FastIO 的版本”吗？我可以直接帮你改成最小侵入式的用法。